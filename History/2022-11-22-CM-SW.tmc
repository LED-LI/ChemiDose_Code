//+++++++++++++++++++++++++++++++++++++++
// Name:        CM_SW.tmc
//
// Description: CM software
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Changes:
//    1. V2010001 initial SW
//    2. V2010002 After rework for separate DIR for capHolder. swappes out3 and out
//    3. V2010003 Initialize works and draws on vial into the bag
//    4. V2010004 Multi- vial opperation
//    5. V2010005 2022 - back to work
//    6. 2022-05-18 corrections
//    7. 2022-08-02 first code' before clean up
//    8. 2022-08-09 go thru code before on machine
//    9. 2022-09-29 homing, capHolder
//   10. 2022-10-05 reference from first vial linear and bump
//   11. 2022-11-05 full cycle with one vial
//   12. 2022-11-14 running all 6 vials from PC
//   13. 2022-11-21 running bottom vials
//   14. 2022-11-22 fix backup problem
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//************
// Includes
//************
// This file:  2022-11-22-CM-SW.tmc

#Include CM_TMCLParam.tmc              // TMCL Parameters
#Include 2022-11-22-CM-Defines.tmc     // CM   definitions
#Include 2022-11-22-CM-Init.tmc        // CM   initialization

///++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Subroutines initialized from PC
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ClearRunningErrors:   // func 84
    CSUB    INIT_MOTORS      // func 16
    CSUB    ClearErrorsRAM

    RSGP    GB_any_Error, GPbank_2             // restore parameter from EEPROM. Now we see if errors in EEPROM
    GGP     GB_any_Error, GPbank_2             // read the parameter. if set, reset data in EEPROM
    COMP    set 
    JC      NE, endClearRunningErrors
    SGP     GB_any_Error, GPbank_2, clr        // signal error: general
    STGP    GB_any_Error, GPbank_2             // erase any error. The errors were erased already in RAM
                                               // in "ClearErrorsRAM", now store in eeprom if needed
    STGP    GB_errors_syringe_bag, GPbank_2
    STGP    GB_errors_M_verticalMotor, GPbank_2
    STGP    GB_errors_M_linearMotor, GPbank_2
    STGP    GB_errors_M_armMotor, GPbank_2
    STGP    GB_errors_M_pistonMotor, GPbank_2
    STGP    GB_errors_M_headRotateMotor, GPbank_2
    STGP    GB_errors_M_disposeMotor, GPbank_2
    STGP    GB_errors_M_capHolderMotor, GPbank_2
    STGP    GB_errors_Vial_1, GPbank_2
    STGP    GB_errors_Vial_2, GPbank_2
    STGP    GB_errors_Vial_3, GPbank_2
    STGP    GB_errors_Vial_4, GPbank_2
    STGP    GB_errors_Vial_5, GPbank_2
    STGP    GB_errors_Vial_6, GPbank_2
    STGP    GB_errors_findHome, GPbank_2
    STGP    GB_errors_wrong_PC_command, GPbank_2
    STGP    GB_special_Error, GPbank_2

endClearRunningErrors:
    SGP     GB_vial1Bit, GPbank_2, 1   //  
    SGP     GB_vial2Bit, GPbank_2, 2   //  
    SGP     GB_vial3Bit, GPbank_2, 4   //  
    SGP     GB_vial4Bit, GPbank_2, 8   //  
    SGP     GB_vial5Bit, GPbank_2, 16  //  
    SGP     GB_vial6Bit, GPbank_2, 32  //  
    SGP     GB_BagBit  , GPbank_2, 64  //  
    CSUB    GREEN_ON
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ClearErrorsRAM:
    SGP     GB_any_Error, GPbank_2, clr                   // signal error: general
    SGP     GB_errors_syringe_bag, GPbank_2, clr          // 28
    SGP     GB_errors_M_verticalMotor, GPbank_2, clr      // 30
    SGP     GB_errors_M_linearMotor, GPbank_2, clr        // 31
    SGP     GB_errors_M_armMotor, GPbank_2, clr           // 32
    SGP     GB_errors_M_pistonMotor, GPbank_2, clr        // 33
    SGP     GB_errors_M_headRotateMotor, GPbank_2, clr    // 34
    SGP     GB_errors_M_disposeMotor, GPbank_2, clr       // 35
    SGP     GB_errors_M_capHolderMotor, GPbank_2, clr     // 36
    SGP     GB_errors_Vial_1, GPbank_2, clr               // 37
    SGP     GB_errors_Vial_2, GPbank_2, clr               // 38
    SGP     GB_errors_Vial_3, GPbank_2, clr               // 39
    SGP     GB_errors_Vial_4, GPbank_2, clr               // 40
    SGP     GB_errors_Vial_5, GPbank_2, clr               // 41
    SGP     GB_errors_Vial_6, GPbank_2, clr               // 42
    SGP     GB_errors_findHome, GPbank_2, clr             // 43
    SGP     GB_errors_wrong_PC_command, GPbank_2, clr     // 44
    SGP     GB_special_Error, GPbank_2, clr               // 45

    //SGP     GB_motorIsMoving, GPbank_2, clr               // 16
    SGP     GB_moveManualBackwards, GPbank_2, 1           // 1 = forward,  -1 = backward
    SGP     GB_CmdInProcess, GPbank_2, clr                //  
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: PC initialises this program after it put the requested option
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INIT_CM:   // func 6

// clear errors and check for syringe
    CSUB    ClearRunningErrors
    CSUB    screenAllVials             // put all vials state into data Base
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM  //   5
    SGP     GB_initialVolume, GPbank_2, clr             //  15
    CSUB    checkOkToInitDrawDoze            // check if in right state,         sets STOPPED_ON_ERROR state
    CSUB    checkNoSyringe                   // check syringe exists,            sets STOPPED_ON_ERROR state
    //CSUB    checkDrawer                      // check if closed and not full and door closed
/////* add after fix of sensor */   CSUB    checkOverFlow         // check if closed and not full and door closed
    //CSUB    checkDoorOpen                    // sliding door has to be closed
    GGP     GB_any_Error, GPbank_2           // get any error status
    COMP    ANY_ERROR_EXISTS                 // exists?
    JC      EQ, returnInitDraw               // error, return (keeps STATE WAITING_INIT_CM)
    CSUB    FIND_HOMES
// ---- ADD DRAW VOLUME INITIALIZATION ----
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH   // Set standby current
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH             // Set standby current
    SGP     GB_CurrentState, GPbank_2, WAITING_DISPENSE
    CSUB    setTestParams

returnInitDraw:
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// initialization for testing
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setTestParams:   //  98

    SGP    GB_BagSize_microL,GPbank_2, 500000
    SGP    GB_microLtoWithdraw_1,GPbank_2, 0
    SGP    GB_microLtoWithdraw_2,GPbank_2, 0
    SGP    GB_microLtoWithdraw_3,GPbank_2, 0
    SGP    GB_microLtoWithdraw_4,GPbank_2, 2000
    SGP    GB_microLtoWithdraw_5,GPbank_2, 0
    SGP    GB_microLtoWithdraw_6,GPbank_2, 0

    SGP    GB_vialSize_microL_1,GPbank_2, 5000
    SGP    GB_vialSize_microL_2,GPbank_2, 5000
    SGP    GB_vialSize_microL_3,GPbank_2, 5000
    SGP    GB_vialSize_microL_4,GPbank_2, 3000
    SGP    GB_vialSize_microL_5,GPbank_2, 5000 
    SGP    GB_vialSize_microL_6,GPbank_2, 5000

    SGP    GB_vibrationTime_4,GPbank_2, 4
    SGP    GB_vibrationTime_56,GPbank_2, 0
    SGP    GB_vibrationHz,GPbank_2, 25
    SGP    GB_vibrStrengthPercentCalc,GPbank_2, 40
    SGP    GB_vibrationDutyCyclePercent, GPbank_2, 40


    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: draw the required amount from each vial and move to the bag
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DRAW_DOSE:  // func 8

    CSUB    ClearRunningErrors
    CSUB    checkOkToDrawDoze          // check if in right state, sets STOPPED_ON_ERROR state
    CSUB    checkDrawVolume            // verify draw volume,      sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // any error?
    JC      EQ, returnDrawDose         // yes, return with STOPPED_ON_ERROR state

    CSUB    screenAllVials             // put all vials state into data Base
    CSUB    VERIFY_READY_DRAW          // check if syringe, vial are loaded
                                       // keeps STATE WAITING_DISPENSE for easy recovery
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      NE, noErrorFound           // yes, return with WAITING_DISPENSE state for easy recovery
// errors found
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current for syringe loading
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH            // Set standby current
    JA      returnDrawDose

noErrorFound:
    CSUB    GREEN_ON
// --------------------
    CSUB    BeforeDraw                                // decap and position 
// --------------------
    CSUB    Vibrate_456                               // if needed: lower vials, fill with seline, vibrate, raise
// ------------------------------------------------------------

    SGP     GB_current_Vial, GPbank_2, LAST_VIAL      // starting with last vial = 6
drawNextVial:
    CALC    LOAD, GB_microLtoWithdraw_1 - 1      // copy GB address minus 1 to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    GIV                                          // the content of the vial withdraw is copied into A
    COMP    0
    JC      LE, decrementCurrentVial
    CSUB    Draw_654321                               // loop on all vials
decrementCurrentVial:
    DJNZ    GB_current_Vial, drawNextVial             // done all vials?

// ------------------------------------------------------------
    CSUB    AfterAllVialsDone                         // decap and position
// ------------------------------------------------------------
    CSUB    incrementCycles                           // YES
    SGP     GB_CurrentState, GPbank_2, WAITING_DISPENSE
//  SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM

  returnDrawDose:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Vibrate_456:

 // check if any vibration is needed, if no, return.
    CSUB    check_vibration_needed
    GGP     GB_vibrationIsNeeded, GPbank_2
    COMP    set
    JC      NE, returnVibrate_456                // if not needed, skip vibrations
// ------------------------------------------------------------
    CSUB    lower_arm
// ------------------------------------------------------------
    SGP     GB_current_Vial, GPbank_2, LAST_VIAL      // 6 starting with last vial
loopFillVials:
    CSUB    fill_a_vial                // loop on all vials
    CALCV   SUB, GB_current_Vial, 1    // decrement current vial
    GGP     GB_current_Vial, GPbank_2  // 
    COMP    FIRST_VIAL_VIBRATE         // 4
    JC      GE, loopFillVials

// ------------------------------------------------------------
    CSUB    vibrate              // run the vibration. Returns immediately
// ----------------------        // vibration is stopped by timer interrupts

    CSUB    waitDoneVibrate  
    CSUB    raise_arm

 returnVibrate_456:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
waitDoneVibrate:

    GGP     GB_vibrator4done, GPbank_2
    COMP    0                               // not done 4
    JC      EQ, waitDoneVibrate   

    GGP     GB_vibrator56done, GPbank_2
    COMP    0                               // not done 56
    JC      EQ, waitDoneVibrate   
                                            // bothe done
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

check_vibration_needed:

    SGP    GB_vibrationIsNeeded, GPbank_2, clr     // assume not needed
    // check if needs to vibrate vial 4
    GGP    GB_vibrationTime_4, GPbank_2
    COMP   0
    JC     NE, vibrationNeeded
    // check if needs to vibrate vials 5 & 6
    GGP    GB_vibrationTime_56, GPbank_2
    COMP   0
    JC     EQ, vibrationNotNeeded

vibrationNeeded:
    SGP    GB_vibrationIsNeeded, GPbank_2, set
vibrationNotNeeded:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
lower_arm:    

    GGP     GB_armAtBottom, GPbank_2             // load to A
    CSUB    moveArmMotor
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
fill_a_vial:  

    CSUB    loadCurrentParametersVibrate   // for GB_current_Vial
    // ------------------------------------------------------------
    // check if need vial 4
    GGP    GB_current_Vial, GPbank_2       // get current vial #
    COMP   5                               // more than 5, i.e. vial 5 or 6?
    JC     GE, check_56_vibration          // yes
 
    // check_4_vibration:                  // no, check vibration time for vial 4
    GGP    GB_vibrationTime_4, GPbank_2
    COMP   0
    JC     EQ, ReturnFill_a_vial          // if viration time = 0, do not vibrate or fill 4
    JA     checkwithdrawMicros

check_56_vibration:    
    GGP    GB_vibrationTime_56, GPbank_2   // no, check vibration time for vial 56
    COMP   0
    JC     EQ, ReturnFill_a_vial          // if viration time = 0, do not vibrate or fill 56

checkwithdrawMicros:
    GGP     GB_microLtoWithdraw_current, GPbank_2    // load withdraw amount
    COMP    0                                        // need to fill this vial
    JC      LE, ReturnFill_a_vial                    // no need to withdraw from this vial

// ------------------------------------------------------------
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM             // Set standby arm motor current normal
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE   // Set standby here to rotate current normal
    CSUB    moveAboveVial
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      EQ, ReturnFill_a_vial      // yes, return
    CSUB    insertNeedleIntoVialBelow
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW  // Set maximum positioning speed
    // empty the vial
    GGP     GB_PistonHomePos, GPbank_2                                      // load to A
    MVPA    ABS, M_pistonMotor                                              // inject into the vial
    WAIT    POS, M_pistonMotor, WAIT_TICKS_SHORT                            // wait till reaches location or 2 seconds
    
   // exit vial from below
    CALC    LOAD, TOP_VERTICAL_NEEDLE_DOWN
    CSUB    moveVertical                               // 10s
   
    
    //this stage is for inserting the vibrated content back into the bag
    //// CSUB    rePositionFromBottomToStart // maybe not the right place for it ....

ReturnFill_a_vial:

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    raise_arm:

    CSUB    positionArmMotor
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Draw_654321:    // check here if this vial is needed

    GGP     GB_current_Vial, GPbank_2       // get vial #
    COMP    6
    JC      GT, error_noVial
    COMP    1
    JC      GE, setCurrentVial

 error_noVial:
    GGP     GB_special_Error, GPbank_2           // load  error word
    CALC    OR, BitEr_vialNotDefined             // add the error bit
    AGP     GB_special_Error, GPbank_2           // and write again
    STGP    GB_special_Error, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnDraw654321
// -------------------------------------------------
 setCurrentVial:
     CSUB    loadCurrentParameters      // for GB_current_Vial

// --------- C A L L   D R A W    S U B  -----------
// DrawRequiredVial:
    CSUB    DrawFromVial   
// -------------------------------------------------

    // load what is left in the vial
    CALC    LOAD, GB_microLinVial_1 - 1          // copy GB address to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    CALCAV  LOAD, GB_microLinVial_current        // Copy current content into A
    AIV                                          // the content of the vial now is copied from A

returnDraw654321:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    loadCurrentParameters:   // for GB_current_Vial

    CSUB    preLoadCurrentParameters

  // calculate vial location
    CALCVV  LOAD, GB_currentVialLinearLocation, GB_linearCenterOfVial1     // to the first vial
    CALCAV  LOAD, GB_current_Vial                // load the vial number 1 -> 6 
    COMP    3                                    // more than 3'rd vial? 
    JC      LE, doNotAdd6
    CALCV   ADD, GB_currentVialLinearLocation, LINEAR_VIAL3to4SPACE  // ADD the distancce from 3 to 4
    CALCV   SUB, GB_currentVialLinearLocation, LINEAR_VIALS_SPACE    // SUB the standard distance between vials

doNotAdd6:    
    CALCAV  LOAD, GB_current_Vial                // load the vial number 0 -> 5 
    CALC    SUB, 1                               // now vials 0-5
    CALC    MUL, LINEAR_VIALS_SPACE              // multiply by the space between vials, total distance in A
    CALCVA  ADD, GB_currentVialLinearLocation        // add to GB_currentVialLinearLocation  

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    loadCurrentParametersVibrate:   // for GB_current_Vial

    CSUB    preLoadCurrentParameters

  // calculate vial location
    CALCAV  LOAD, GB_current_Vial                // load the vial number 1 -> 6 
    COMP    3                                    // less than 3 --> error, cannot vibrate
    JC      LE, returnloadCurrentParametersVibrate

    CALCVV  LOAD, GB_currentVialLinearLocation, GB_SetVial4BottomLinear
    CALCAV  LOAD, GB_current_Vial                // load the vial number 0 -> 5 
    CALC    SUB, 4                               // now vials 0-5
    CALC    MUL, LINEAR_VIALS_SPACE              // multiply by the space between vials, total distance in A
    CALCVA  ADD, GB_currentVialLinearLocation        // add to GB_currentVialLinearLocation  

returnloadCurrentParametersVibrate:   // for GB_current_Vial
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
preLoadCurrentParameters:

    CALC    LOAD, GB_microLtoWithdraw_1 - 1      // copy GB address to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    GIV                                          // the content of the vial withdraw is copied into A
    CALCVA  LOAD, GB_microLtoWithdraw_current    // and loaded into current parameter

    // load current quantity in the vial
    CALC    LOAD, GB_microLinVial_1 - 1          // copy GB address to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    GIV                                          // the content of the vial now is copied into A
    CALCVA  LOAD, GB_microLinVial_current        // and loaded into current parameter

    // load vial size
    CALC    LOAD, GB_vialSize_microL_1 - 1       // copy GB address to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    GIV                                          // the content of the vial size is copied into A
    CALCVA  LOAD, GB_vialSize_microL_current     // and loaded into current parameter

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   BeforeDraw:  //  vial #: GB_current_Vial 

    CSUB    deCap
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    DrawFromVial:  //  vial #: GB_current_Vial 

    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE   // Set standby here to rotate current normal
   // pull air
    CSUB    startPullAir70                             // pull 70% of the air
   // ---------------------------------------
    CSUB    moveBelowVial
    CSUB    waitPiston
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      EQ, ReturnDrawFromVial     // yes, return
    CSUB    insertNeedleIntoVial
   // pushAir
    CSUB    push70air
    CSUB    drawVial
    CSUB    drawVialMoreBack
    CSUB    moveSlowlyBottom
    CSUB    bumpPlunger
    CSUB    goIntoBag
    CSUB    injectIntoBag
    CSUB    rePositionToStart

ReturnDrawFromVial:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    AfterAllVialsDone:  //  vial #: GB_current_Vial 

    CSUB    PositionHeadRotateMotor
    CSUB    positionLinearMotor
    CSUB    recapSyringe

    // drop vials

    GGP     GB_DisposeDropVialsPos, GPbank_2
    MVPA    ABS, M_disposeMotor                        // move, wait later

    GGP     GB_DisposeDropVials456Pos, GPbank_2
    MVPA    ABS, M_armMotor                           // move, wait later

    CSUB    waitDispose
    CSUB    waitArmMotor

    WAIT    TICKS, 0, WAIT_TICKS                      // wait 10 seconds till all vials rest

    CSUB    HomeDisposeMotor    
    CSUB    positionArmMotor    
    // check if overflow
/////* add after fix of sensor */   CSUB    checkOverFlow         // check if closed and not full and door closed

returnAfterAllVialsDone:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToDrawDoze:

    SGP     GB_errors_wrong_PC_command, GPbank_2, clr
    GGP     GB_CurrentState, GPbank_2                      // current state to A
    COMP    WAITING_DISPENSE
    JC      EQ, okToDrawDoze                               // if EQ, continue

 // this not is the time for DrawDose
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load  error word
    CALC    OR, BitEr_expecting_WAITING_DISPENSE          // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckOkDraw

okToDrawDoze:
    SGP     GB_CurrentState, GPbank_2, RUNNING_DISPENSE
returnCheckOkDraw:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkDrawVolume:
 // check if too much all together
    CALCAV  LOAD, GB_microLtoWithdraw_1                  // add the draw volume 1
    CALCAV  ADD, GB_microLtoWithdraw_2                   // add the draw volume 2
    CALCAV  ADD, GB_microLtoWithdraw_3                   // add the draw volume 3
    CALCAV  ADD, GB_microLtoWithdraw_4                   // add the draw volume 4
    CALCAV  ADD, GB_microLtoWithdraw_5                   // add the draw volume 5
    CALCAV  ADD, GB_microLtoWithdraw_6                   // add the draw volume 6
    AGP     GB_microLbagToFill, GPbank_2                 // save into the required volume to fill in the BAG
    CALCAV  SUB, GB_BagSize_microL                       // compare to the Bag's size
    COMP    0                                            // more than maximum permitted?
    JC      LE, returnDrawLimit                          // no, report error and stop

 drawVolumeExeeds:
    GGP     GB_errors_syringe_bag, GPbank_2              // load  error word
    CALC    OR, BitEr_volumeExceedsBag                   // add the error bit
    AGP     GB_errors_syringe_bag, GPbank_2              // and write again
    STGP    GB_errors_syringe_bag, GPbank_2              // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnDrawLimit:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

screenAllVials:  // sub 36     check the Vial status, set the global parameter
             // according to state

    SIO     Out_Multiplexer, OutBank_2, 1            // change relays to watch vials
    WAIT    TICKS, 0, 90/10                          // 90 ms
    SGP     GB_vialsExist, GPbank_2, 0               // clear vials word

check1:
    GIO     InX_vialIsIn1, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check2
    CALCV   OR, GB_vialsExist, Bit_vial1
check2:
    GIO     InX_vialIsIn2, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check3
    CALCV   OR, GB_vialsExist, Bit_vial2
check3:
    GIO     InX_vialIsIn3, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check4
    CALCV   OR, GB_vialsExist, Bit_vial3
check4:
    GIO     InX_vialIsIn4, InBankDigital_0             // check if Vial is in
    COMP    0
////    JC      EQ, check5
    CALCV   OR, GB_vialsExist, Bit_vial4
check5:
    GIO     InX_vialIsIn5, InBankDigital_0             // check if Vial is in
    COMP    0
////    JC      EQ, check6
    CALCV   OR, GB_vialsExist, Bit_vial5
check6:
    GIO     InX_vialIsIn6, InBankDigital_0             // check if Vial is in
    COMP    0
////    JC      EQ, checkBag
    CALCV   OR, GB_vialsExist, Bit_vial6
checkBag:
    GIO     InX_salineBagIsIn, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, doneCheckVials
    CALCV   OR, GB_vialsExist, Bit_bag
doneCheckVials:
    GGP     GB_vialsExist, GPbank_2                  // check if any vial is in
    COMP    0                                        // is the Vial in?
    JC      NE, returnVerifyAllVial                  // if not, continue
 // error - no vials
    GGP     GB_special_Error, GPbank_2               // load the error word
    CALC    OR, BitEr_No_vials                       // add the error bit
    AGP     GB_special_Error, GPbank_2               // and write again
    STGP    GB_special_Error, GPbank_2               // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifyAllVial:
    SIO     Out_Multiplexer, OutBank_2, 0            // change relays to watch inputs
    WAIT    TICKS, 0, 100/10                         // 100 ms
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary:  checks if the vial' syrine and are ready to draw
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VERIFY_READY_DRAW:    //  checks if syringe, vail are in place

    SGP     GB_readyToDraw, GPbank_2, clr               // not ready to draw (assume)
    CSUB    verifySyringe
    CSUB    verifyVIAL

    GGP     GB_any_Error, GPbank_2                      // get any error status
    COMP    ANY_ERROR_EXISTS                            // exists?
    JC      NE, returnVerify
 // errors
    CSUB    setAnyErrorYellow
    SGP     GB_CurrentState, GPbank_2, WAITING_DISPENSE
    RSUB
returnVerify:
    SGP     GB_readyToDraw, GPbank_2, set               // ready to draw
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifySyringe:  // check the syringe status, set the global parameter
                // according to state

    CSUB    checkSyringeSensor                          // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnVerifySyringe                     // syringe is in

syringeMissing:
    GGP     GB_special_Error, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_SyringeMissing                    // add the error bit
    AGP     GB_errors_syringe_bag, GPbank_2             // and write again
    STGP    GB_errors_syringe_bag, GPbank_2             // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifySyringe:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifyVIAL:  // func 34
             // check the Vial status, set the global parameter
             // according to state

//GB_microLtoWithdraw_1        =  91
//GB_microLtoWithdraw_2        =  92
//GB_microLtoWithdraw_3        =  93
//GB_microLtoWithdraw_4        =  94
//GB_microLtoWithdraw_5        =  95
//GB_microLtoWithdraw_6        =  96

//GB_vialSize_microL_1             = 101
//GB_vialSize_microL_2             = 102
//GB_vialSize_microL_3             = 103
//GB_vialSize_microL_4             = 104
//GB_vialSize_microL_5             = 105
//GB_vialSize_microL_6             = 106

// --------------------
verify_vial_1:
    // vial needed?
    GGP     GB_microLtoWithdraw_1, GPbank_2     // vial needed?
    COMP    0
    JC      LE, verify_vial_2                   // not needed, check next vial
    // vial is too small?
    CALCAV  SUB, GB_vialSize_microL_1           // A gets the result
    COMP    0
    JC      LE, vial1InPlace                    // vial is large enough
    CALCV   OR, GB_errors_Vial_1, BitEr_VialTooSmall
    STGP    GB_errors_Vial_1, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
vial1InPlace:
    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial1
    COMP    0                                           // is the Vial in?
    JC      NE, verify_vial_2
    CALCV   OR, GB_errors_Vial_1, BitEr_VialMissing     // add error
    STGP    GB_errors_Vial_1, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

// --------------------
verify_vial_2:
    // vial needed?
    GGP     GB_microLtoWithdraw_2, GPbank_2     // vial needed?
    COMP    0
    JC      LE, verify_vial_3                   // not needed, check next vial
    // vial is too small?
    CALCAV  SUB, GB_vialSize_microL_2           // A gets the result
    COMP    0
    JC      LE, vial2InPlace                    // vial is large enough
    CALCV   OR, GB_errors_Vial_2, BitEr_VialTooSmall
    STGP    GB_errors_Vial_2, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
vial2InPlace:
    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial2
    COMP    0                                           // is the Vial in?
    JC      NE, verify_vial_3
    CALCV   OR, GB_errors_Vial_2, BitEr_VialMissing     // add error
    STGP    GB_errors_Vial_2, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

// --------------------
verify_vial_3:
    // vial needed?
    GGP     GB_microLtoWithdraw_3, GPbank_2     // vial needed?
    COMP    0
    JC      LE, verify_vial_4                   // not needed, check next vial
    // vial is too small?
    CALCAV  SUB, GB_vialSize_microL_3           // A gets the result
    COMP    0
    JC      LE, vial3InPlace                    // vial is large enough
    CALCV   OR, GB_errors_Vial_3, BitEr_VialTooSmall
    STGP    GB_errors_Vial_3, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
vial3InPlace:
    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial3
    COMP    0                                           // is the Vial in?
    JC      NE, verify_vial_4
    CALCV   OR, GB_errors_Vial_3, BitEr_VialMissing     // add error
    STGP    GB_errors_Vial_3, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

// --------------------
verify_vial_4:
    // vial needed?
    GGP     GB_microLtoWithdraw_4, GPbank_2     // vial needed?
    COMP    0
    JC      LE, verify_vial_5                   // not needed, check next vial
    // vial is too small?
    CALCAV  SUB, GB_vialSize_microL_4           // A gets the result
    COMP    0
    JC      LE, vial4InPlace                    // vial is large enough
    CALCV   OR, GB_errors_Vial_4, BitEr_VialTooSmall
    STGP    GB_errors_Vial_4, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
vial4InPlace:
    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial4
    COMP    0                                           // is the Vial in?
    JC      NE, verify_vial_5
    CALCV   OR, GB_errors_Vial_4, BitEr_VialMissing     // add error
    STGP    GB_errors_Vial_4, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

// --------------------
verify_vial_5:
    // vial needed?
    GGP     GB_microLtoWithdraw_5, GPbank_2     // vial needed?
    COMP    0
    JC      LE, verify_vial_6                   // not needed, check next vial
    // vial is too small?
    CALCAV  SUB, GB_vialSize_microL_5           // A gets the result
    COMP    0
    JC      LE, vial5InPlace                    // vial is large enough
    CALCV   OR, GB_errors_Vial_5, BitEr_VialTooSmall
    STGP    GB_errors_Vial_5, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
vial5InPlace:
    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial5
    COMP    0                                           // is the Vial in?
    JC      NE, verify_vial_6
    CALCV   OR, GB_errors_Vial_5, BitEr_VialMissing     // add error
    STGP    GB_errors_Vial_5, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

// --------------------
verify_vial_6:
    // vial needed?
    GGP     GB_microLtoWithdraw_6, GPbank_2     // vial needed?
    COMP    0
    JC      LE, returnVerifyVial                   // not needed, check next vial
    // vial is too small?
    CALCAV  SUB, GB_vialSize_microL_6           // A gets the result
    COMP    0
    JC      LE, vial6InPlace                    // vial is large enough
    CALCV   OR, GB_errors_Vial_6, BitEr_VialTooSmall
    STGP    GB_errors_Vial_6, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
vial6InPlace:
    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial6
    COMP    0                                           // is the Vial in?
    JC      NE, returnVerifyVial
    CALCV   OR, GB_errors_Vial_6, BitEr_VialMissing     // add error
    STGP    GB_errors_Vial_6, GPbank_2                  // store vial 1 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

// --------------------
returnVerifyVial:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

deCap:    // GB_74

    CSUB    homeCapHolderMotor
    CSUB    holdCap
    CSUB    homeLinearMotor                           // go through home once per cycle
    CALCAV  LOAD, GB_linearCenterOfVial1
    CSUB    moveLinear
    CSUB    checkSyrPoppedOut                         // verify that the syringe did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

startPullAir70:  //  pull 20% of the air

    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCAV  MUL, GB_microLtoWithdraw_current            // A <multiply by the "20%"
    CALC    DIV, 100                                    // now in uSteps
    CALCAV  MUL, GB_airToPullBefore                     // multiply by "20%"
    CALC    DIV, 100                                    // A = 70% in uSteps
    MVPA    REL, M_pistonMotor                          // move, wait later
    CSUB    waitPiston
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveBelowVial:   //

    CSUB    HomeHeadRotateMotor                        // Rotate to sensor for home
    GGP     GB_HeadRotateHomePos, GPbank_2             // load to A
    CALC    SUB, DEGREES_90                            // substitute to turn upward
    CSUB    moveRotate                                 // move to location
// go under current vial
    CALCAV  LOAD, GB_BumpPosVert
    CALC    ADD, BAG_ENTRY_BELOW_BUMP                  // load Vial1 position
    CSUB    moveVertical                               // move head up to sensor, wait later
    GGP     GB_currentVialLinearLocation, GPBank_2     // copy into A (GB_50)
    CSUB    moveLinear
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveAboveVial:   //

// go below Bag to fill syringe
    CSUB    HomeHeadRotateMotor                        // Rotate to sensor for home
    GGP     GB_HeadRotateHomePos, GPbank_2             // load to A
    CALC    SUB, DEGREES_90                            // substitute to turn upward
    CSUB    moveRotate                                 // move to location
//    CSUB    findCenterOfNeedleSensor

    CSUB    goIntoBag
    CSUB    drawFromBag
    CSUB    rePositionToStart

    GGP     GB_HeadRotateHomePos, GPbank_2             // load to A
    CALC    ADD, DEGREES_90                            // turn down
    CSUB    moveRotate                                 // 10s

    CALC    LOAD, TOP_VERTICAL_NEEDLE_DOWN
    CSUB    moveVertical                               // 10s


    GGP     GB_currentVialLinearLocation, GPBank_2     // copy into A (GB_50)
    CSUB    moveLinear
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

push70air:

    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCAV  MUL,  GB_microLtoWithdraw_current           // A <-- A*load the withdraw volume [uL] -> [uSteps*100]
    CALC    DIV, 100                                    // now in uSteps
    CALCAV  MUL, GB_airToPullBefore                     // multiply by "70%"
    CALC    DIV, -100                                   // A = 70% in uSteps
    MVPA    REL, M_pistonMotor                          // move, wait later
    CSUB    waitPiston
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

findCenterOfNeedleSensor:

    CSUB    HomeHeadRotateMotor                        // Rotate to sensor for home
    GGP     GB_HeadRotateHomePos, GPbank_2             // load to A
    CALC    SUB, DEGREES_90                            // substitute to turn upward
    CSUB    moveRotate                                 // move to location
    GGP     GB_linearCenterOfVial1, GPbank_2           // load Vial1 position
    CALC    ADD, LINEAR_VIAL1_TO_BAG_RFS               // start of needle RFS posotion
    CSUB    moveLinear
    CSUB    homeVerticalMotor                          // move vertical to home position
    CALCAV  LOAD, GB_BumpPosVert
    CALC    ADD, VER_NEEDLE_RFS_BELOW_BUMP             // load Vial1 position
    CSUB    moveVertical                               // move head up to sensor, wait later
// first RFS
    SAP     AP_RefSearchSpeed, M_linearMotor, SEARCH_SPEED_LINEAR_BOTTLE      // speed for search
    SAP     AP_RefSwitchSpeed, M_linearMotor, SWITCH_SPEED_LINEAR_BOTTLE      // speed for final search
    SAP     AP_RefSearchMode,  M_linearMotor, APV_RefHomeLeft                 // search needle mode
    RFS     START, M_linearMotor                                              // Start reference search
    WAIT    RFS, M_linearMotor, WAIT_NEEDLE_REF          // wait till reaches location or 0.8 seconds
    JC      ETO, secondRFSback                           // timeout occured
    JA      endFindNeedle
secondRFSback:
    RFS     STOP, M_linearMotor                         // Stops reference search
    WAIT    RFS, M_linearMotor, WAIT_TICKS_SHORT        // wait till stops or 2 seconds
    SAP     AP_RefSearchMode,  M_linearMotor, APV_RefHomeRight  // search needle
    RFS     START, M_linearMotor                    // Start reference search
    CSUB    waitLinearMotorRfs
endFindNeedle:
    GAP     AP_LastRefPosition, M_linearMotor         // get position of reference
    AAP     AP_ActualPosition, M_linearMotor          // copy into current location
    AGP     GB_LinearCenterOfBag, GPBank_2            // remember position of reference
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

insertNeedleIntoVial:    //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    GGP     GB_BumpPosVert, GPbank_2                       // load to A
    MVPA    ABS, M_verticalMotor                           // move to location
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL // Set maximum positioning speed
    MVP     REL, M_verticalMotor, VERTICAL_IN_VIAL         // insert needle into vial
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    CSUB    checkVialPoppedOut                           // verify that the vial did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

insertNeedleIntoVialBelow:    //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    GGP     GB_setBumpBottom, GPbank_2                       // load to A
    MVPA    ABS, M_verticalMotor                           // move to location
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL // Set maximum positioning speed
    MVP     REL, M_verticalMotor, VERTICAL_IN_VIAL_BELOW  // insert needle into vial
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    CSUB    checkVialPoppedOut                           // verify that the vial did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

drawVial:    // just pull to required volume

    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW   // Set maximum positioning speed
    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCAV  MUL, GB_microLtoWithdraw_current            // A = A* [uSteps*100]
    CALC    DIV, 100                                    // now in uSteps
    MVPA    REL, M_pistonMotor                          // move, wait later
    CSUB    waitPistonDraw

    MVP     REL, M_pistonMotor, PISTON_MORE             // move more
    CSUB    waitPiston
    CSUB    waitAfterDraw
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed

    // calculate the volume left in the vial
    CALCVV  SUB, GB_microLinVial_current, GB_microLtoWithdraw_current  // add to total in vial

returnDrawVial:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

drawVialMoreBack:    // just pull to required volume

    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW  // Set maximum positioning speed
  // always push for later bump
    MVP     REL, M_pistonMotor, -BUMP_DOWN_REL          // re-push to compensate the "bump"
    CSUB    waitPiston
    MVP     REL, M_pistonMotor, -PISTON_MORE            // push back the 300[uL]
    CSUB    waitPiston
// returnMoreBack:
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitAfterDraw:

    //GGP     GB_DrawWaitTime, GPbank_2              // get time in [100ms]
    CALC    LOAD, 300                              // wait 3 sec till SW calculate
    WAIT    TICKS, 0, ACCUMULATOR_WAIT             // wait ticks as in A
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveSlowlyBottom:    //

    GGP     GB_BumpPosVert, GPbank_2               // go to required height
    CSUB    moveVertical                           // move, wait and error if delay
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bumpPlunger:   //

    MVP     REL, M_pistonMotor, BUMP_DOWN_REL           // bump piston
    CSUB    waitPiston
// the piston bump will run in parallel to the vertical down, and wait after start of vertical
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

goIntoBag:   //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    CALCAV  LOAD, GB_BumpPosVert
    CALC    ADD, BAG_ENTRY_BELOW_BUMP                  // load Vial1 position
    MVPA    ABS, M_verticalMotor                       // move to location
    CSUB    waitVertical

   // GGP     GB_LinearCenterOfBag, GPbank_2           // go left under bag position
   // CSUB    moveLinear
    CSUB      findCenterOfNeedleSensor                 // find center of bag

    CALCAV  LOAD, GB_BumpPosVert
    CALC    ADD, BAG_ENTRY_BELOW_BUMP                  // load Vial1 position
    CSUB    moveVertical                               // move head up to sensor, wait later

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL  // Set maximum positioning speed
    MVP     ABS, M_verticalMotor, SYRINGE_IN_BAG_ABS                            // move to location
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH     // Set maximum positioning speed

   RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
injectIntoBag:
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW  // Set maximum positioning speed
    GGP     GB_PistonHomePos, GPbank_2                                      // load to A
    MVPA    ABS, M_pistonMotor                            // move, wait later
    CSUB    waitPistonDraw
    // SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST    // Set maximum positioning speed
    // calculate the volume in the bag
    CALCVV  ADD, GB_microLinBAG, GB_microLtoWithdraw_current                // add to total in bag

    RSUB
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
drawFromBag: 
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW  // Set maximum positioning speed

    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCAV  MUL, GB_microLtoWithdraw_current            // A = A* [uSteps*100]
    CALC    DIV, 100                                    // now in uSteps
    MVPA    REL, M_pistonMotor                         // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS_SHORT      // wait till reaches location or 2 seconds
    SGP     GB_MotorIsMoving, GPbank_2, clr

    //   SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed
    // calculate the volume in the bag
    CALCVV  SUB, GB_microLinBAG, GB_microLtoWithdraw_current                // add to total in bag


    RSUB
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rePositionToStart:   //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
  // move down, out of the bag
    CALCAV  LOAD, GB_BumpPosVert
    CALC    ADD, BAG_ENTRY_BELOW_BUMP                  // load Vial1 position
    MVPA    ABS, M_verticalMotor                                            // move to location
    CSUB    waitVertical
  // move linear and rotate to rotation position
    CALCAV  LOAD, GB_linearCenterOfVial1
    CSUB    moveLinear
    CSUB    inProcessFindHomes

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rePositionFromBottomToStart:   //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
  //////////////////////////////// rotate at center of hight and point needle up ->
  ///////////////////////////////// exit vial from bottom to rotation position ->
    // raise needle - to avoid rotating in vial bellow
    CALC  LOAD, TOP_VERTICAL_NEEDLE_DOWN
    CSUB    moveVertical                               // 10s
    // MVPA    ABS, M_verticalMotor                                            // move to location
    // CSUB    waitVertical
    // rotate needle to point to start (left)
    // CSUB    PositionHeadRotateMotor
    CSUB    HomeHeadRotateMotor                                          // Rotate to sensor for home
    // CSUB    homeHeadRotateMotorSlow                                     // find fast, before slow

    // lower needle - to avoid rotating into vial on top
                                                                    // todo // !!! CHECK !!!
    CALC  LOAD, VERTICAL_BACK_TO_CENTER                                   // might be covered
    CSUB    moveVertical                               // 10s
    // MVPA    ABS, M_verticalMotor                                            // in other function
    // CSUB    waitVertical                                                    // of "goIntoBag"
                                            // CSUB    goIntoBag
  // rotate needle to point up ->
    GGP     GB_HeadRotateHomePos, GPbank_2                                  // load to A
    CALC    SUB, DEGREES_90                                                 // substitute to turn upward
    CSUB    moveRotate                                                      // move to location    CSUB    moveRotate                                 // move to location
    
  // reposition under bag ->
    CSUB    findCenterOfNeedleSensor
  
  // ready to insert content

  // ?? MAYBE in the end ?? //// L.E.D
    // CSUB    inProcessFindHomes // i dont want to move position to "Homes" after reaching start into bag ////L.E.D

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

recapSyringe:   //

    //GGP     GB_linearLoading, GPbank_2                     // go back to loading position
    GGP     GB_linearCenterOfVial1, GPbank_2
    CALC    ADD, LINEAR_VIAL1_TO_LOADING
    CSUB    moveLinear
    CSUB    homeCapHolderMotor                             // to home switch upwards

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

incrementCycles:   // function 112
    CALCV   ADD, GB_cyclesTotal, 1
    STGP    GB_cyclesTotal, GPbank_2                   // store it in EEPROM
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Subroutines initialized localy
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: Performs axis homeing
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FIND_HOMES:

    SGP     GB_HomingDone, GPbank_2, clr            // clear homing done
    CSUB    checkNoSyringeFH                        // make sure no syringe is in
    GGP     GB_any_Error, GPbank_2                  // get any error status
    COMP    ANY_ERROR_EXISTS                        // exists?
    JC      EQ, return_FIND_HOME                    // yes, return
    CSUB    startHomePistonMotor
    CSUB    startHomeDisposeMotor
    CSUB    homeCapHolderMotor                      // Linear and Cap holders first to clear the way for vertical
    CSUB    homeLinearMotor                         // Linear and Cap holders first to clear the way for vertical
    CSUB    positionPistonMotor
    CSUB    positionArmMotor
    CSUB    waitHomeDisposeMotor
    CSUB    positionVerticalMotor                   // get it out of Linear and cap
    CSUB    PositionHeadRotateMotor
    CSUB    positionLinearMotor
    SGP     GB_HomingDone, GPbank_2, set            // home done
return_FIND_HOME:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inProcessFindHomes:    // no CAP, no ARM

    SGP     GB_HomingDone, GPbank_2, clr            // clear homing done
    //CSUB    startHomePistonMotor
    CSUB    startHomeDisposeMotor
    CSUB    homeLinearMotor                         // Linear and Cap holders first to clear the way for vertical
    //CSUB    positionPistonMotor
    CSUB    waitHomeDisposeMotor
    CSUB    positionVerticalMotor                   // get it out of Linear and cap
    //CSUB    PositionHeadRotateMotor
    //CSUB    positionLinearMotor
    SGP     GB_HomingDone, GPbank_2, set            // home done

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkVialPoppedOut:

    CSUB    screenAllVials                       // put all vials state into data Base
    GGP     GB_current_vial, GPBank_2            // current vial
    CALC    LOAD, GB_vial1Bit - 1                // copy GB address to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    GIV                                          // the content of the vial bit is copied into A
    CALCAV  AND, GB_vialsExist                   // AND vial bit with GB_vialsExist
    COMP    0
    JC      NE, returnVialPoppedOut              // if NE, vial did not pop out

 // vial popped out, signal errors
 
    CALC    LOAD, GB_errors_Vial_1 - 1           // copy GB address to A
    CALCAV  ADD, GB_current_Vial                 // add vial number  0 -> 5
    CALCX   LOAD                                 // the address is in X
    GIV                                          // the content of the vial errors is copied into A
    CALC    OR, BitEr_VialPoppedOut              // add the error bit
    AIV                                          // and copied back to vial errors
    //STGP    GB_errors_syringe_bag, GPbank_2    // cannot store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnVialPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToInitDrawDoze:

    SGP     GB_errors_wrong_PC_command, GPbank_2, clr
    GGP     GB_CurrentState, GPbank_2        // InitDrawDoze can run if WAITING_INIT_CM or if WAITING_DISPENSE
    COMP    WAITING_INIT_CM                  // WAITING_INIT_CM?
    JC      EQ, okToInitDrawDoze             // yes, return
    GGP     GB_CurrentState, GPbank_2        // no, try next
    COMP    WAITING_DISPENSE                             // WAITING_DISPENSE?
    JC      EQ, okToInitDrawDoze                         // yes, return
    // InitDrawDoze does not fit, signal errors
    GGP     GB_errors_wrong_PC_command, GPbank_2         // load error word
    CALC    OR, BitEr_expecting_GP5_10_OR_30             // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2         // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2         // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckInitDraw

okToInitDrawDoze:    
    SGP     GB_CurrentState, GPbank_2, RUNNING_INIT_CM

returnCheckInitDraw:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkNoSyringe:

    CSUB    checkSyringeSensor                          // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      NE, returnCheckNoSyringe                    // if not, continue
    // syringe found, signal errors
    GGP     GB_special_Error, GPbank_2                  // load the error word
    CALC    OR, BitEr_SyringeIsIn                       // add the error bit
    AGP     GB_errors_syringe_bag, GPbank_2             // and write again
    STGP    GB_errors_syringe_bag, GPbank_2             // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnCheckNoSyringe:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkNoSyringeFH:

    CSUB    checkSyringeSensor  // AP_RightLimitSwitchState, M_pistonMotor  // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      NE, noSyringeFH                             // if not, continue
    // syringe found, signal errors
    GGP     GB_errors_findHome, GPbank_2                // load piston error word
    CALC    OR, BitEr_syringeIsInwhileFindHome          // add the error bit
    AGP     GB_errors_findHome, GPbank_2                // and write again
    STGP    GB_errors_findHome, GPbank_2                // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckNoSyringeFH

noSyringeFH:
    GGP     GB_errors_findHome, GPbank_2                // load piston error word
    CALC    OR, BitEr_syringeIsInwhileFindHome          // add the error bit
    CALC    XOR, BitEr_syringeIsInwhileFindHome         // Clear the error bit
    AGP     GB_errors_findHome, GPbank_2                // and write again
    STGP    GB_errors_findHome, GPbank_2                // and store it

returnCheckNoSyringeFH:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
checkSyrPoppedOut:

    CSUB    checkSyringeSensor  // AP_RightLimitSwitchState, M_pistonMotor  // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut                      // if in, continue to check vial
 // syringe popped out, signal errors
    GGP     GB_errors_syringe_bag, GPbank_2             // load Ver002 error word
    CALC    OR, BitEr_syringePoppedOut                  // add the error bit
    AGP     GB_errors_syringe_bag, GPbank_2             // and write again
    STGP    GB_errors_syringe_bag, GPbank_2             // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnSyrPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
checkDrawer:       // check if drawer closed, not full and door closed

    GIO     In_drawerClose, InBankDigital_0        // read drawer sensor
    COMP    DRAWER_IS_CLOSED                       // is the drawer closed?
    JC      EQ, returnSyrPoppedOut                 // if in, continue to check vial
 // drawer is open, signal errors
    GGP     GB_special_Error, GPbank_2             // load Ver002 error word
    CALC    OR, BitEr_drawerIsOpen                 // add the error bit
    AGP     GB_special_Error, GPbank_2             // and write again
    STGP    GB_special_Error, GPbank_2             // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnCheckDrawer:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
checkOverFlow:       // check if empty vials overflow drawer

    GIO     In_drawerOverflow, InBankDigital_0   // check if Vial is in
    COMP    OVERFLOW
    JC      NE, returnCheckOverFlow
    // error
    GGP     GB_special_Error, GPbank_2           // load  error word
    CALC    OR, BitEr_drawerOverflow             // add the error bit
    AGP     GB_special_Error, GPbank_2           // and write again
    STGP    GB_special_Error, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    
returnCheckOverFlow:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
checkDoorOpen:       // check if door closed

    GIO     In_slidingDoor, InBankDigital_0        // read drawer sensor
    COMP    DOOR_IS_CLOSED                         // is the drawer closed?
    JC      EQ, returnCheckDoor                    // if in, continue to check vial
 // door is open, signal errors
    GGP     GB_special_Error, GPbank_2             // load Ver002 error word
    CALC    OR, BitEr_slidingDoorIsOpen            // add the error bit
    AGP     GB_special_Error, GPbank_2             // and write again
    STGP    GB_special_Error, GPbank_2             // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnCheckDoor:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkSyringeSensor:
    GAP     AP_RightLimitSwitchState, M_pistonMotor     // put syringe status in A
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Manual Axis movements 
//  Use carefully, only in direct mode
//  The movement consists of the following commands.
//  The global parameter GP_uPulsesManual (address 19)  holds the micro-meters 
//  or mili-degrees to go, which can be negative or positive.
//  Before sending the next movement look if GB_MotorIsMoving (GB_16) is clear
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VerticalManual:    // func 136    motor 0

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALCAV  MUL, GB_moveManualBackwards                 // 1 = forward,  -1 = backward
    CALC    MUL, verticalMicroStepsPerMM              
    CALC    DIV, 1000                                   // now in uSteps
    MVPA    REL, M_verticalMotor                         // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS_SHORT      // wait till reaches location or 2 seconds
    JC      ETO, verticalMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB    

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveVertical:    // 

    MVPA    ABS, M_verticalMotor                         // move, wait later
    CSUB    waitVertical
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVertical:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS            // wait till reaches location or 10 seconds
    JC      ETO, verticalMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVerticalLong:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS_LONG        // wait till reaches location or 15 seconds
    JC      ETO, verticalMotorTOerr                      // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
 
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVerticalRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_verticalMotor, WAIT_TICKS_LONG         // wait end of reference search 15 seconds
    JC      ETO, verticalMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
 
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

positionVerticalMotor:          // motor 0   30
    CSUB      homeVerticalMotor                                          // to home switch upwards
    GGP       GB_verticalCapPos, GPbank_2
    CSUB      moveVertical
    RSUB

homeVerticalMotor:          // 102  to home switch upwards
    SAP       AP_MaxAcceleration, M_verticalMotor, ACC_VERT_HIGH         // Set maximum acceleration
    SAP       AP_RefSearchMode,  M_verticalMotor, APV_RefLeftSwitch      // set the kind of search just go up
    RFS       START, M_verticalMotor                                     // Start home sw search UP, then' if reached ref, Down
    CSUB      waitVerticalRfs
    SAP       AP_MaxAcceleration, M_verticalMotor, ACC_VERT              // Set maximum acceleration
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verticalMotorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_verticalMotor, GPbank_2         // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_verticalMotor, GPbank_2         // and write again
    STGP    GB_errors_M_verticalMotor, GPbank_2         // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LinearMotorManual:    //   func 138

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALCAV  MUL, GB_moveManualBackwards                 // 1 = forward,  -1 = backward
    CALC    MUL, linearMicrostepsPerMM                
    CALC    DIV, 1000                                   // now in mDeg
    MVPA    REL, M_linearMotor                            // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_linearMotor, WAIT_TICKS_SHORT        // wait till reaches location or 2 second
    JC      ETO, linearMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB    

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveLinear:    // 

    MVPA    ABS, M_linearMotor                            // move, wait later
    CSUB    waitLinearMotor
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitLinearMotor:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_linearMotor, WAIT_TICKS_LINEAR    // wait till reaches location or 20 seconds
    JC      ETO, LinearMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitLinearMotorRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_linearMotor, WAIT_TICKS           // wait end of reference search 15 seconds
    JC      ETO, LinearMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

positionLinearMotor:   // func 56
    //GGP       GB_linearLoading, GPbank_2
    GGP       GB_linearCenterOfVial1, GPbank_2
    CALC      ADD, LINEAR_VIAL1_TO_LOADING
    CSUB      moveLinear
    RSUB

homeLinearMotor:    // motor 1   func 42
    SAP       AP_StandbyCurrent, M_linearMotor, STBY_CURRENT_LINEAR_HIGH   // Set standby current
    SAP       AP_RefSearchSpeed, M_linearMotor, SEARCH_SPEED_LINEAR_HOME   // speed for search
    SAP       AP_RefSwitchSpeed, M_linearMotor, SWITCH_SPEED_LINEAR_HOME   // speed for final search
    SAP       AP_RefSearchMode, M_linearMotor, APV_RefLeftSwitch
    RFS       START, M_linearMotor                                         // Start reference search
    CSUB      waitLinearMotorRfs
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LinearMotorTOerr:   

    CSUB    setAnyError
    GGP     GB_errors_M_linearMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                        // add the error bit
    AGP     GB_errors_M_linearMotor, GPbank_2        // and write again
    STGP    GB_errors_M_linearMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

armMotorManual:    //   func 140

    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH      // Set standby current
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM
    GGP     GB_UnitsToMoveManual, GPbank_2        // load the movement [mDeg] into A
    CALCAV  MUL, GB_moveManualBackwards                 // 1 = forward,  -1 = backward
    CALC    MUL, ArmMicrostepsPerDeg                
    CALC    DIV, 1000                             // now in mDeg
    MVPA    REL, M_armMotor                         // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_armMotor, WAIT_TICKS_SHORT     // wait till reaches location or 2 seconds
    JC      ETO, armMotorTOerr              // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveArmMotor:    // 

    MVPA    ABS, M_armMotor                         // move, wait later
    CSUB    waitArmMotor
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitArmMotor:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_armMotor, WAIT_TICKS_ARM        // wait till reaches location or 10 seconds
    JC      ETO, armMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitArmMotorRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_armMotor, WAIT_TICKS           // wait end of reference search 15 seconds
    JC      ETO, armMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

positionArmMotor:             // motor 2   func 96
    CSUB      homeArmMotor                                          // to home switch upwards
    GGP       GB_ArmVialPosition, GPbank_2
    CSUB      moveArmMotor
    RSUB

homeArmMotor:  // 50
    SAP       AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH      // Set standby current
    SAP       AP_RefSearchMode, M_armMotor, APV_RefLeftSwitch
    RFS       START, M_armMotor                                     // Start reference search
    CSUB      waitArmMotorRfs
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

armMotorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_armMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                     // add the error bit
    AGP     GB_errors_M_armMotor, GPbank_2        // and write again
    STGP    GB_errors_M_armMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PistonManual:    // func 142

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALCAV  MUL, GB_moveManualBackwards                 // 1 = forward,  -1 = backward
    CALC    MUL, pistonMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
    MVPA    REL, M_pistonMotor                            // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS_SHORT        // wait till reaches location or 2 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

movePiston:    // 

    MVPA    ABS, M_pistonMotor                            // move, wait later
    CSUB    waitPiston
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPiston:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS              // wait till reaches location or 10 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPistonDraw:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS_DRAW         // wait till reaches location or 10 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPistonRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_pistonMotor, WAIT_TICKS             // wait end of reference search 15 seconds
    JC      ETO, pistonMotorTOerr                      // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

homePistonMotor:     // motor 3   104
    CSUB      startHomePistonMotor
    CSUB      waitPistonRfs
    CSUB      positionPistonMotor
    RSUB

startHomePistonMotor:  // 124
    SAP       AP_RefSearchMode,  M_pistonMotor, APV_RefLeftSwitch  
    RFS       START, M_pistonMotor                                          // Start reference search
    RSUB

positionPistonMotor:       // func 106                                                 // wait home sensor and position
    CSUB      waitPistonRfs
    GGP       GB_PistonHomePos, GPbank_2                                    // go to required height
    CSUB      movePiston                                                    // move, wait and error if delay
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pistonMotorTOerr:   

    CSUB    setAnyError
    GGP     GB_errors_M_pistonMotor, GPbank_2           // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_pistonMotor, GPbank_2           // and write again
    STGP    GB_errors_M_pistonMotor, GPbank_2           // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RotationManual:    //   func 144

    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current 
    SAP     AP_LeftLimitSwitchDisable, M_headRotateMotor, set           // Disable left limit switch
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [mDeg] into A
    CALCAV  MUL, GB_moveManualBackwards                 // 1 = forward,  -1 = backward
    CALC    MUL, rotateMicrostepsPerDeg                 // 
    CALC    DIV, 1000                                   // now in mDeg
    MVPA    REL, M_headRotateMotor                        // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS_SHORT    // wait till reaches location or 2 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveRotate:    // 

    MVPA    ABS, M_headRotateMotor                        // move, wait later
    CSUB    waitRotate
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotate:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS          // wait till reaches location or 10 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateLong:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS_LONG     // wait till reaches location or 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_LONG     // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsShort:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_SHORT   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                  // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsNeedle:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_NEEDLE   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsVeryShort:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_VERY_SHORT   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PositionHeadRotateMotor:   // motor 4  38
    CSUB      HomeHeadRotateMotor
    GGP       GB_HeadRotateHomePos, GPbank_2                                // go to required height
    CSUB      moveRotate                                                    // move, wait and error if delay
    RSUB

HomeHeadRotateMotor:   // 58
    CSUB      homeHeadRotateMotorFast                                       // find fast, before slow
//    CSUB      homeHeadRotateMotorSlow                                     // find fast, before slow
    RSUB

homeHeadRotateMotorSlow:
    SAP       AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT_SLOW   // speed for search slow
    SAP       AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT_SLOW   // speed for final search
    SAP       AP_RefSearchMode,  M_headRotateMotor, APV_RefLeftSwitch  
    RFS       START, M_headRotateMotor                                      // Start reference search
    CSUB      waitRotateRfs
    RSUB

homeHeadRotateMotorFast:   
    SAP       AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT        // speed for search
    SAP       AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT        // speed for final search
    SAP       AP_RefSearchMode,  M_headRotateMotor, APV_RefLeftSwitch  
    RFS       START, M_headRotateMotor                                      // Start reference search
    CSUB      waitRotateRfs
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

headRotateMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_headRotateMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                            // add the error bit
    AGP     GB_errors_M_headRotateMotor, GPbank_2        // and write again
    STGP    GB_errors_M_headRotateMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DisposeManual:    //   func 154

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALCAV  MUL, GB_moveManualBackwards                 // 1 = forward,  -1 = backward
    CALC    MUL, disposeMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
    MVPA    REL, M_disposeMotor                        // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_disposeMotor, WAIT_TICKS_SHORT    // wait till reaches location or 2 seconds
    JC      ETO, disposeMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveDispose:    // 

    MVPA    ABS, M_disposeMotor                        // move, wait later
    CSUB    waitDispose
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitDispose:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_disposeMotor, WAIT_TICKS          // wait till reaches location or 10 seconds
    JC      ETO, disposeMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitDisposeRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_disposeMotor, WAIT_TICKS         // wait end of reference search 15 seconds
    JC      ETO, disposeMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HomeDisposeMotor:       // motor 5   52
    CSUB      startHomeDisposeMotor
    CSUB      waitHomeDisposeMotor
    RSUB

startHomeDisposeMotor:       // motor 5   92
    SAP       AP_StandbyCurrent, M_disposeMotor, STBY_CURRENT_DISPOSE   // Set standby current
    SAP       AP_RefSearchMode, M_disposeMotor, APV_RefLeftSwitch
    RFS       START, M_disposeMotor                                     // Start reference search
    RSUB

waitHomeDisposeMotor:
    CSUB      waitDisposeRfs
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

disposeMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_disposeMotor, GPbank_2         // load disposal error word
    CALC    OR, BitEr_TimeOut                          // add the error bit
    AGP     GB_errors_M_disposeMotor, GPbank_2         // and write again
    STGP    GB_errors_M_disposeMotor, GPbank_2         // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CapHolderManual:   // FUNC 156   

//   GB_UnitsToMoveManual             = 19    // for manual movement, put here the microMeter to move (+/-)
//   GB_CapHolderPulses               = 87    
//   GB_slowCapHolder                 = 88

//    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_CM

    GGP     GB_UnitsToMoveManual, GPbank_2              // GB_19 load the movement [uMeter] into A
    CALC    MUL, capHolderMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
    CALCVA  LOAD, GB_CapHolderPulses                    // The required pulses in GB
    SGP     GB_MotorIsMoving, GPbank_2, set
// check direction
    SIO     Out_CAPHolderDIR_Down, OutBank_2, set       // assume "down", positive steps
    GGP     GB_UnitsToMoveManual, GPbank_2              // GB_19 load the movement [uMeter] into A
    COMP    0
    JC      GE, CapGoDownwards                          // as assumed
// change to UP
    SIO     Out_CAPHolderDIR_Down, OutBank_2, clr       // assume positive steps, go up
    CALCV   MUL, GB_CapHolderPulses, -1                 // change pulses to absolute
CapGoDownwards:
// move the motor
    SGP     GB_MotorIsMoving, GPbank_2, set
    SGP     GB_capWaitLoops, GPbank_2, CAP_WAIT_LOOPS

nextStep:   //  loop
// check if to test sensor
    GIO     Out_CAPHolderDIR_Down, InBankOuput_2
    COMP    1
    JC      EQ, moveOneStep                             // going down, don't check sensor
//    GGP     GB_CapLimitSwitchDisable, GPbank_2
//    COMP    DISABLE_SENSOR
//    JC      EQ, moveOneStep                           // going down, don't check sensor
    GIO     In_capHolderHome, InBankDigital_0                 
    COMP    CAP_HOLDER_AT_HOME             
    JC      EQ, exitCapHolderManual                     // reached home sensor, exit
moveOneStep:
    SIO     Out_PulseCapHolder, OutBank_2, 0            // pulse up
    SIO     Out_PulseCapHolder, OutBank_2, 1            // pulse down
    GGP     GB_slowCapHolder, GPbank_2                  // move slowy?
    COMP    0
    JC      ZE, fastLoop
    WAIT    TICKS, 0, 1                                 // wait 10 ms
fastLoop:
    DJNZ    GB_capWaitLoops, contCap                    // check if 10 seconds passed (5000 loops)
    JA      capHolderMotorTOerr                         // if stuck, error
contCap:
    DJNZ    GB_CapHolderPulses, nextStep                //  if not zero: decrement and jump 
exitCapHolderManual:
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 testCapHolder:    // func 158

    //SGP     GB_UnitsToMoveManual, GPbank_2, -6000              // move up to start position
    //CSUB    CapHolderManual
    CSUB    homeCapHolderMotor
    //SGP     GB_UnitsToMoveManual, GPbank_2, CAP_LOCK_STEPS
    //CSUB    CapHolderManual
    CSUB    holdCap
    WAIT  TICKS, 0, 100                                      // wait 1 s
    JA    testCapHolder
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

homeCapHolderMotor:     // func 122

    SGP   GB_UnitsToMoveManual, GPbank_2, -6000     // move upward 10 mm till stop at home sensor
    CSUB  CapHolderManual                           // FUNC 140  run and error if too long
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

holdCap:  // func 118

    SGP   GB_UnitsToMoveManual, GPbank_2, CAP_LOCK_STEPS     // move down to close position
    CSUB  CapHolderManual
    WAIT  TICKS, 0, 100                                      // wait 1 s
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

capHolderMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_capHolderMotor, GPbank_2        // load cap holder error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_capHolderMotor, GPbank_2        // and write again
    STGP    GB_errors_M_capHolderMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// VIBRATE
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
defaultVibrate:   // func 126
    SGP    GB_vibrationTime_4, GPbank_2, 3
    SGP    GB_vibrationTime_56, GPbank_2, 2
    SGP    GB_vibrationHz, GPbank_2, 25
    SGP    GB_vibrationDutyCyclePercent, GPbank_2, 40
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
StopVibrate:   // FUNC 120   
    DI     TI_TIMER0     
    DI     TI_TIMER1 
    DI     TI_TIMER2 
    SGP    GB_vibrator4done, GPbank_2, 1
    SGP    GB_vibrator56done, GPbank_2, 1
    CALCV  LOAD, GB_vibrationTime_4_calc, 0
    CALCV  LOAD, GB_vibrationTime_56_calc, 0
    SIO    Out_enaVibrate_4, GPbank_2, 1           // switch off OUT0 high vibrator 4
    SIO    Out_enaVibrate_56, GPbank_2, 1          // switch off OUT1 high vibrator 56
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Vibrate:   // FUNC 114   

// GB_vibrationTime_4           = 114        // Input: in seconds
// GB_vibrationTime_4_calc      = 115
// GB_vibrationTime_56          = 116        // Input: in seconds
// GB_vibrationTime_56_calc     = 117
// GB_vibrationDutyCyclePercent = 123        // 10/20/30/40/.../100
// GB_vibrStrengthPercentCalc   = 119        // Input: %  vibrationStrength
// GB_PwmDutyCycleMS            = 120        // calculated [ms]
// GB_vibrator4done             = 121
// GB_vibrator56done            = 122
// GB_vibrationCycleMS          = 124        // ms
// GB_vibrationHz               = 125        // Input: data input

//  reset current vibration
    CSUB   StopVibrate

// check strength validity                       // acceptable values 10-100
    GGP      GB_vibrationDutyCyclePercent, GPbank_2
    COMP     10               
    JC       LT, errorVibrateParameter
    //GGP      GB_vibrationDutyCyclePercent, GPbank_2
    COMP     100
    JC       GT, errorVibrateParameter

// check HZ validity                       // acceptable values 4-100 HZ
    GGP      GB_vibrationHz, GPbank_2
    COMP     100
    JC       GT, errorVibrateParameter
    //GGP      GB_vibrationHz, GPbank_2
    COMP     4
    JC       LT, errorVibrateParameter

// check TIME validity                       // acceptable values > 0 [s]
    GGP      GB_vibrationTime_4, GPbank_2
    COMP     0
    JC       LT, errorVibrateParameter
    SGP      GB_vibrator4done, GPbank_2, 0     // assume, will sign when it finished
    JC       NE, check56
    SGP      GB_vibrator4done, GPbank_2, 1     // will sign when it finished
check56:
    GGP      GB_vibrationTime_56, GPbank_2
    COMP     0
    JC       LT, errorVibrateParameter
    SGP      GB_vibrator56done, GPbank_2, 0    // assume, will sign when it finished
    JC       NE, loadParameters
    SGP      GB_vibrator56done, GPbank_2, 1    // will sign when it finished
 
loadParameters:
    CALCVV   LOAD, GB_vibrationTime_4_calc, GB_vibrationTime_4
    CALCVV   LOAD, GB_vibrationTime_56_calc, GB_vibrationTime_56

// calculate cycle time from HZ
    CALC     LOAD, 500                     // load 500 to A
    CALCAV   DIV, GB_vibrationHz           // cycle MS = 500(=A) / HZ = 1000/Hz/2
    CALCVA   LOAD, GB_vibrationCycleMS     // load into GB

// calculate duty cycle time:  pecentage of the full cycle
    CALCVV   LOAD, GB_vibrStrengthPercentCalc, GB_vibrationDutyCyclePercent
    //CALCV    MUL, GB_vibrStrengthPercentCalc, 10                  // 1->10 ... 10->100 
    CALCVV   LOAD, GB_PwmDutyCycleMS, GB_vibrationCycleMS           // ms
    CALCVV   MUL, GB_PwmDutyCycleMS, GB_vibrStrengthPercentCalc     // ms * % *100
    CALCV    DIV, GB_PwmDutyCycleMS, 100                            // :100 = ms

    // ----- RUN VIBRATIONS ------
    CSUB   initInterrups                     // re-initialize
    // ---------------------------
    JA     endVibrate

errorVibrateParameter:
    GGP     GB_errors_wrong_PC_command, GPbank_2        // load Ver002 error word
    CALC    OR, BitEr_vibrateParemeterError             // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2        // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2        // and store it
    CSUB    setStateSTOPPED_ON_ERROR
    JA      ABORT_NoReport
    
endVibrate:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  calibration functions  
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HomeCalibration:
    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_verticalMotor
    JC      EQ, calibMotorVertical

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_linearMotor
    JC      EQ, calibMotorLinear

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_armMotor
    JC      EQ, calibMotorArm

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_pistonMotor
    JC      EQ, calibMotorPiston

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_headRotateMotor
    JC      EQ, calibMotorRotate

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_capHolderMotor
    JC      EQ, calibMotorCap

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_disposeMotor
    JC      EQ, calibMotorDispose

    JA     returnHomeCalibration

calibMotorVertical:
    CSUB   homeVerticalMotor
    JA     returnHomeCalibration

calibMotorLinear:
    CSUB   homeLinearMotor
    JA     returnHomeCalibration

calibMotorArm:
    CSUB   homeCapHolderMotor
    JA     returnHomeCalibration

calibMotorPiston:
    CSUB   homePistonMotor
    JA     returnHomeCalibration

calibMotorRotate:
    CSUB   HomeHeadRotateMotor
    JA     returnHomeCalibration

calibMotorDispose:
    CSUB   HomeDisposeMotor
    JA     returnHomeCalibration

calibMotorCap:
    CSUB   homeCapHolderMotor
    JA     returnHomeCalibration

returnHomeCalibration:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setStateSTOPPED_ON_ERROR:

    SGP     GB_CurrentState, GPbank_2, STOPPED_ON_ERROR
    CSUB    setAnyError
    RSUB
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setStateSTOPPED_ON_ERROR_Yellow:

    SGP     GB_CurrentState, GPbank_2, STOPPED_ON_ERROR
    STGP    GB_CurrentState, GPbank_2
    CSUB    setAnyErrorYellow
    RSUB
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setAnyError:

    SGP     GB_any_Error, GPbank_2, set                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    RED_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setAnyErrorYellow:

    SGP     GB_any_Error, GPbank_2, set                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    YELLOW_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

clrAnyError:

    SGP     GB_any_Error, GPbank_2, clr                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    GREEN_ON
    RSUB


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
GREEN_ON:
    SIO     Out_RedLED, OutBank_2, LED_OFF                   // turn off red led
    SIO     Out_GreenLED, OutBank_2, LED_ON                  // turn on green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
RED_ON:
    SIO     Out_RedLED, OutBank_2, LED_ON                    // turn on red led
    SIO     Out_GreenLED, OutBank_2, LED_OFF                 // turn off green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
YELLOW_ON:
    SIO     Out_RedLED, OutBank_2, LED_ON                     // turn on red led
    SIO     Out_GreenLED, OutBank_2, LED_ON                   // turn on green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LEDS_OFF:
    SIO     Out_RedLED, OutBank_2, LED_OFF                    // turn off red led
    SIO     Out_GreenLED, OutBank_2, LED_OFF                  // turn off green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Eyals_dummy_sub:
    
    
    
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++