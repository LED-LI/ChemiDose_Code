//+++++++++++++++++++++++++++++++++++++++
// Name:        CM_SW.tmc
//
// Description: CM software
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Changes:
//    1. V2010001 initial SW
//    2. V2010002 After rework for separate DIR for capHolder. swappes out3 and out
//    3. V2010003 Initialize works and draws on vial into the bag
//    4. V2010004 Multi-vial opperation
//    5.V2010005 2022 - back to work
//    6.
//    7.
//    8.
//    9.
//   10.
//   12.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//************
// Includes
//************
// This file:  2020-03-13-CM-SW.tmc

#Include CM_TMCLParam.tmc              // TMCL Parameters
#Include 2020-03-14-CM-Defines.tmc     // CM   definitions
#Include 2022-03-14-CM-Init.tmc        // CM   initialization

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// stop all motors and return
// - stop program at the calling function
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ABORT:
    SGP     GB_CurrentState, GPbank_2, ABORTED
    GGP     GB_errors_syringe, GPbank_2          // load  error word
    CALC    OR, BitEr_machineAborted                    // add the error bit
    AGP     GB_errors_syringe, GPbank_2          // and write again
    STGP    GB_errors_syringe, GPbank_2          // and store it

ABORT_NoReport:
    SAP     AP_MaxAcceleration, M_verticalMotor, ACC_VERT_HIGH     // stop quicker
    MST     M_verticalMotor                             // Stop up down
    MST     M_linearMotor                               // Stop
    MST     M_armMotor                                  // Stop
    MST     M_pistonMotor                               // Stop fill syringe
    MST     M_headRotateMotor                           // Stop move
    MST     M_disposeMotor                           // Stop move
    SIO     Out_PulseCapHolder, OutBank_2, 0            // disable capHolder motor
    SIO     Out_CAPHolderDIR_Down, OutBank_2, 0         // reset DIR for capHolderMotor
    SIO     Out_VibrateDIR, OutBank_2, 1                // reset DIR for 2 vibrators
    SIO     Out_enaVibrate_0, OutBank_2, 1              // disable vibrator_1
    SIO     Out_enaVibrate_1, OutBank_2, 1              // disable vibrator_2
    SGP     GB_slowCapHolder, GPbank_2, 0               //  set cap holder fast move. "1" will slow for homing
    SGP     GB_MotorIsMoving, GPbank_2, clr
    CSUB    RED_ON                                      // red LED
//    DI      TI_STOPLEFT5                              //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5                             //  dipper interrupt
    WAIT    TICKS, 0, 100                                                // wait one second for all the motors to stop
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_LOW    // Set standby current low to enable moving the rotation down
    SAP     AP_MaxAcceleration, M_verticalMotor, ACC_VERT                // Set maximum acceleration
    RST     BACK_GROUND_PROCESS                         // Stop a running TMCL program. Reset program counter and stack pointer

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Subroutines initialized from PC
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Name: CLEAR_ALL_ERRORS
//
// Summary: reset all errors
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CLEAR_ALL_ERRORS:    // func 4

    RST     continueClearErrors                //Stop a running TMCL program. Reset program counter and stack pointer
                                               // to zero. Reset accumulator and X register to zero. Reset all flags.
continueClearErrorS:    // stack is now empty
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE  //   5
    SGP     GB_initialVolume, GPbank_2, clr                    //  15
    SGP     GB_MotorIsMoving, GPbank_2, clr                    //  16
    CSUB    INIT
    CSUB    ClearErrorsRAM
    JA      ABORT_NoReport                                     // no return stack

ClearRunningErrors:   // func 84
    CSUB    INIT
    CSUB    ClearErrorsRAM

    RSGP    GB_any_Error, GPbank_2           // restore parameter from EEPROM. Now we see if errors in EEPROM
    GGP     GB_any_Error, GPbank_2           // read the parameter. if set, reset data in EEPROM
    COMP    set
    JC      NE, endClearRunningErrors
    SGP     GB_any_Error, GPbank_2, clr        // signal error: general
    STGP    GB_any_Error, GPbank_2             // erase any error. The errors were erased already in RAM
                                               // in "ClearErrorsRAM", now store in eeprom if needed
    STGP    GB_errors_syringe, GPbank_2
    STGP    GB_errors_M_verticalMotor, GPbank_2
    STGP    GB_errors_M_linearMotor, GPbank_2
    STGP    GB_errors_M_armMotor, GPbank_2
    STGP    GB_errors_M_pistonMotor, GPbank_2
    STGP    GB_errors_M_headRotateMotor, GPbank_2
    STGP    GB_errors_M_disposeMotor, GPbank_2
    STGP    GB_errors_M_capHolderMotor, GPbank_2
    STGP    GB_errors_Vial_0, GPbank_2
    STGP    GB_errors_Vial_1, GPbank_2
    STGP    GB_errors_Vial_2, GPbank_2
    STGP    GB_errors_Vial_3, GPbank_2
    STGP    GB_errors_Vial_4, GPbank_2
    STGP    GB_errors_Vial_5, GPbank_2
    STGP    GB_errors_findHome, GPbank_2
    STGP    GB_errors_wrong_PC_command, GPbank_2
    STGP    GB_special_Error, GPbank_2

endClearRunningErrors:
    CSUB    GREEN_ON
    RSUB

ClearErrorsRAM:
    SGP     GB_any_Error, GPbank_2, clr                   // signal error: general
    SGP     GB_errors_syringe, GPbank_2, clr       // 28
    SGP     GB_errors_M_verticalMotor, GPbank_2, clr      // 30
    SGP     GB_errors_M_linearMotor, GPbank_2, clr        // 31
    SGP     GB_errors_M_armMotor, GPbank_2, clr           // 32
    SGP     GB_errors_M_pistonMotor, GPbank_2, clr        // 33
    SGP     GB_errors_M_headRotateMotor, GPbank_2, clr    // 34
    SGP     GB_errors_M_disposeMotor, GPbank_2, clr       // 35
    SGP     GB_errors_M_capHolderMotor, GPbank_2, clr     // 36
    SGP     GB_errors_Vial_0, GPbank_2, clr               // 37
    SGP     GB_errors_Vial_1, GPbank_2, clr               // 38
    SGP     GB_errors_Vial_2, GPbank_2, clr               // 39
    SGP     GB_errors_Vial_3, GPbank_2, clr               // 40
    SGP     GB_errors_Vial_4, GPbank_2, clr               // 41
    SGP     GB_errors_Vial_5, GPbank_2, clr               // 42
    SGP     GB_errors_findHome, GPbank_2, clr             // 43
    SGP     GB_errors_wrong_PC_command, GPbank_2, clr     // 44
    SGP     GB_special_Error, GPbank_2, clr               // 45
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: PC initialises this program after it put the requested option
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INIT_DRAW_DOSE:

//    DI      TI_STOPLEFT4               //  Left rotate reference
//    EI      TI_STOPLEFT5               //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5              //  dipper interrupt

// clear errors and check for syringe
    CSUB    ClearRunningErrors
    CSUB    checkOkToInitDrawDoze            // check if in right state,         sets STOPPED_ON_ERROR state
    CSUB    checkNoSyringe                   // check syringe exists,            sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2           // get any error status
    COMP    ANY_ERROR_EXISTS                 // exists?
    JC      EQ, returnInitDraw               // error, return (keeps STATE WAITING_INIT_DRAW_DOSE)
    CSUB    FIND_HOMES
waitMotors:  // wait for both                                   // **** ADD DRAW VOLUME INITIALIZATION ****
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH   // Set standby current
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH             // Set standby current
    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE

returnInitDraw:
//    DI      TI_STOPLEFT4               //  Left rotate reference
//    DI      TI_STOPLEFT5               //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5              //  dipper interrupt

    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: MASTER_DRAW
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

MASTER_DRAW:

//    DI      TI_STOPLEFT4               //  Left rotate reference
//    EI      TI_STOPLEFT5               //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5              //  dipper interrupt

    CSUB    ClearRunningErrors
    CSUB    checkOkToDrawDoze          // check if in right state, sets STOPPED_ON_ERROR state
    CSUB    checkDrawVolume            // verify draw volume,      sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // any error?
    JC      EQ, returnDrawDose         // yes, return with STOPPED_ON_ERROR state

    CSUB    screenAllVials             // put all vials state into data Base
    CSUB    VERIFY_READY_DRAW          // check if syringe, vial are loaded
                                       // keeps STATE WAITING_DRAW_DOSE for easy recovery
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      NE, noErrorFound           // yes, return with WAITING_DRAW_DOSE state for easy recovery
 // errors found
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current for syringe loading
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH            // Set standby current
    JA      returnDrawDose

noErrorFound:
    CSUB    GREEN_ON
    CSUB    decapSyringe
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM             // Set standby arm motor current normal
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE   // Set standby here to rotate current normal
pullAir:
//    CSUB    startPullAir70                             // pull 70% of the air
pullAirDone:
    CSUB    moveBelowVial
//    CSUB    waitPiston
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      EQ, returnDrawDose         // yes, return
    CSUB    insertNeedle
pushAir:
//    CSUB    push70air
drawAll:
    CSUB    drawVial
    CSUB    drawVialMoreBack
    CSUB    moveSlowlyBottom
    CSUB    bumpPlunger
    CSUB    goIntoBag
    CSUB    rotateDown
    CSUB    recapSyringe

//    EI      TI_STOPRIGHT5              //  dipper interrupt

    CSUB    incrementCycles

    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE
//  SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE

 // in case we do not want to stop in the dose calibrator, enable following 4 lines
 //   SGP     GB_microLtoWithdraw, GPbank_2, 0      //eliminate filling the syringe
 //   SGP     GB_activityIsCorrect, GPbank_2, clr   // activitity is bad so will recycle after CHECK_DONE
 //   WAIT    TICKS, 0, 200                         // now wait 2 seconds
 //   JA      CHECK_DONE

 returnDrawDose:
//    DI      TI_STOPLEFT4               //  Left rotate reference
//    DI      TI_STOPLEFT5               //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5              //  dipper interrupt

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++







//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: draw
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DRAW_DOSE:

//    DI      TI_STOPLEFT4               //  Left rotate reference
//    EI      TI_STOPLEFT5               //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5              //  dipper interrupt

    CSUB    ClearRunningErrors
    CSUB    checkOkToDrawDoze          // check if in right state, sets STOPPED_ON_ERROR state
    CSUB    checkDrawVolume            // verify draw volume,      sets STOPPED_ON_ERROR state
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // any error?
    JC      EQ, returnDrawDose         // yes, return with STOPPED_ON_ERROR state

    CSUB    screenAllVials             // put all vials state into data Base
    CSUB    VERIFY_READY_DRAW          // check if syringe, vial are loaded
                                       // keeps STATE WAITING_DRAW_DOSE for easy recovery
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      NE, noErrorFound           // yes, return with WAITING_DRAW_DOSE state for easy recovery
 // errors found
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current for syringe loading
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH            // Set standby current
    JA      returnDrawDose

noErrorFound:
    CSUB    GREEN_ON
    CSUB    decapSyringe
    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM             // Set standby arm motor current normal
    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE   // Set standby here to rotate current normal
pullAir:
//    CSUB    startPullAir70                             // pull 70% of the air
pullAirDone:
    CSUB    moveBelowVial
//    CSUB    waitPiston
    GGP     GB_any_Error, GPbank_2     // get any error status
    COMP    ANY_ERROR_EXISTS           // exists?
    JC      EQ, returnDrawDose         // yes, return
    CSUB    insertNeedle
pushAir:
//    CSUB    push70air
drawAll:
    CSUB    drawVial
    CSUB    drawVialMoreBack
    CSUB    moveSlowlyBottom
    CSUB    bumpPlunger
    CSUB    goIntoBag
    CSUB    rotateDown
    CSUB    recapSyringe

//    EI      TI_STOPRIGHT5              //  dipper interrupt

    CSUB    incrementCycles

    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE
//  SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE

 // in case we do not want to stop in the dose calibrator, enable following 4 lines
 //   SGP     GB_microLtoWithdraw, GPbank_2, 0      //eliminate filling the syringe
 //   SGP     GB_activityIsCorrect, GPbank_2, clr   // activitity is bad so will recycle after CHECK_DONE
 //   WAIT    TICKS, 0, 200                         // now wait 2 seconds
 //   JA      CHECK_DONE

 returnDrawDose:
//    DI      TI_STOPLEFT4               //  Left rotate reference
//    DI      TI_STOPLEFT5               //  syringe pop out interrupt
//    DI      TI_STOPRIGHT5              //  dipper interrupt

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToDrawDoze:

    SGP     GB_errors_wrong_PC_command, GPbank_2, clr
    GGP     GB_CurrentState, GPbank_2                      // current state to A
    COMP    WAITING_DRAW_DOSE
    JC      EQ, okToDrawDoze                               // if EQ, continue

 // this not is the time for DrawDose
    GGP     GB_errors_wrong_PC_command, GPbank_2           // load  error word
    CALC    OR, BitEr_expecting_WAITING_DRAW_DOSE          // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2           // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2           // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckOkDraw

okToDrawDoze:
    SGP     GB_CurrentState, GPbank_2, RUNNING_DRAW_DOSE
returnCheckOkDraw:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkDrawVolume:
 // check if too much
    GGP     GB_initialVolume, GPbank_2                   // load the initial volume [uL] into A
    CALCAV  ADD, GB_microLtoWithdraw                     // add the draw volume
    AGP     GB_initialVolume, GPbank_2                   // save into the current volume (for volume testing)
    CALCAV  SUB, GB_Max_Volume_current                     // add the draw volume
    COMP    0                                            // more than maximum permitted?
    JC      GT, drawVolumeExeeds                         // no, report error and stop

// checkMinimumNoPrefill:
    GGP     GB_initialVolume, GPbank_2                   // load the draw volume [uL] into A
    COMP    MINIMUM_DRAW_VOLUME                          //
    JC      GE, returnDrawLimit                          // yes, exit
                                                         // no. report error and stop
drawVolumeExeeds:
    SGP     GB_errors_volumeExceedsLimits, GPbank_2, set // signal error: syringe
    STGP    GB_errors_volumeExceedsLimits, GPbank_2      // declare vail, syringe or pig error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnDrawLimit:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

screenAllVials:  // sub 36     check the Vial status, set the global parameter
             // according to state

    SIO     Out_Multiplexer, OutBank_2, 1            // change relays to watch vials
    WAIT    TICKS, 0, 300/10                         // 300 ms
    SGP     GB_vialsExist, GPbank_2, 0               // clear vials word

check0:
    GIO     InX_bottle0, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check1
    CALCV   OR, GB_vialsExist, Bit_vial0
check1:
    GIO     InX_bottle1, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check2
    CALCV   OR, GB_vialsExist, Bit_vial1
check2:
    GIO     InX_bottle2, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check3
    CALCV   OR, GB_vialsExist, Bit_vial2
check3:
    GIO     InX_bottle3, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check4
    CALCV   OR, GB_vialsExist, Bit_vial3
check4:
    GIO     InX_bottle4, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, check5
    CALCV   OR, GB_vialsExist, Bit_vial4
check5:
    GIO     InX_bottle5, InBankDigital_0             // check if Vial is in
    COMP    0
    JC      EQ, doneCheckVials
    CALCV   OR, GB_vialsExist, Bit_vial5
doneCheckVials:
    GGP     GB_vialsExist, GPbank_2                  // check if any vial is in
    COMP    0                                        // is the Vial in?
    JC      NE, returnVerifyAllVial                  // if not, continue
 // error - no vials
    GGP     GB_special_Error, GPbank_2               // load the error word
    CALC    OR, BitEr_VialMissing                    // add the error bit
    AGP     GB_special_Error, GPbank_2               // and write again
    STGP    GB_special_Error, GPbank_2               // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifyAllVial:
    SIO     Out_Multiplexer, OutBank_2, 0            // change relays to watch inputs
    WAIT    TICKS, 0, 300/10                         // 300 ms
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary:  checks if the vial' syrine and are ready to draw
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VERIFY_READY_DRAW:    //  checks if syringe, vail are in place

    SGP     GB_readyToDraw, GPbank_2, clr               // not ready to draw (assume)
    CSUB    verifySyringe
    CSUB    verifyVIAL

    GGP     GB_any_Error, GPbank_2                      // get any error status
    COMP    ANY_ERROR_EXISTS                            // exists?
    JC      NE, returnVerify
 // errors
    CSUB    setAnyErrorYellow
    SGP     GB_CurrentState, GPbank_2, WAITING_DRAW_DOSE
    RSUB
returnVerify:
    SGP     GB_readyToDraw, GPbank_2, set               // ready to draw
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifySyringe:  // check the syringe status, set the global parameter
                // according to state

    CSUB    checkSyringeSensor                          // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnVerifySyringe                     // syringe is in

syringeMissing:
    GGP     GB_special_Error, GPbank_2                  // load Ver002 error word
    CALC    OR, BitEr_SyringeMissing                    // add the error bit
    AGP     GB_special_Error, GPbank_2                  // and write again
    STGP    GB_special_Error, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifySyringe:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verifyVIAL:  // func 34
             // check the Vial status, set the global parameter
             // according to state

    GGP     GB_vialsExist, GPbank_2                     // vials word into A
    CALC    AND, Bit_vial0
    COMP    0                                           // is the Vial in?
    JC      NE, returnVerifyVial                        // if not, continue

    CALCV   OR, GB_errors_Vial_0, BitEr_VialMissing
    STGP    GB_errors_Vial_0, GPbank_2                  // store vial 0 error
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnVerifyVial:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

decapSyringe:    //

    SGP     GB_UnitsToMoveManual, GPbank_2, CAP_LOCK_STEPS
    CSUB    CapHolderManual
    CSUB    homeLinearMotor                           // go through home once per cycle
    CALC    LOAD, LINEAR_ROTATE_POS
    MVPA    ABS, M_linearMotor                        // move to location
    CSUB    waitLinearMotor
//    CSUB    homeCapHolderMotor                      // cap holder out of the way
//    CSUB    checkSyrPoppedOut                       // verify that the syringe did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

startPullAir70:  //  pull 70% of the air

    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCX   LOAD                                        // move it to X [uStep/100uL]
    GGP     GB_microLtoWithdraw, GPbank_2               // load the withdraw volume [uL] into A
    CALCX   MUL                                         // A <-- A*X [uSteps*100]
    CALC    DIV, 100                                    // now in uSteps
    CALCX   LOAD                                        // copy to X
    GGP     GB_airToPullBefore, GPbank_2                // get the "70%"
    CALCX   MUL                                         // calculate 70%
    CALC    DIV, 100                                    // now in uSteps
    CALCX   LOAD                                        // relative uSteps in X
    GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    CALCX   ADD                                         // add current position to required relative
    MVPA    ABS, M_pistonMotor                          // move, wait later
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveBelowVial:   //

    GGP     GB_HeadRotateHomePos, GPbank_2             // load to A
    CALC    SUB, NEINTY_DEGREES/2
    MVPA    ABS, M_headRotateMotor                     // move to location
    CSUB    waitRotate                                 // 10s
    CSUB    findCenterOfNeedleSensor
// go under first vial
    GGP     GB_LinearCenterOfBag, GPBank_2             // copy into A
    CALCAV  ADD, GB_linearBagToVial0                   // add relative distance to first vial
    MVPA    ABS, M_linearMotor                         // move to location
    CSUB    waitLinearMotor
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

findCenterOfNeedleSensor:

    MVP     ABS, M_linearMotor, LINEAR_NEEDLE_RFS        // move to location
    CSUB    homeVerticalMotor                            // move vertical to home position
    MVP     ABS, M_verticalMotor, VERTICAL_FOR_NEEDLE    // move head up to sensor, wait later
    CSUB    HomeHeadRotateMotor                          // Rotate to sensor for home
    CALCAV  LOAD, GB_HeadRotateHomePos                   // put horizontal degree in A
    CALC    SUB, NEINTY_DEGREES                          // in A the vertical angle
    MVPA    ABS, M_headRotateMotor                       // move vertical
    CSUB    waitRotate
    CSUB    waitLinearMotor
    CSUB    waitVertical
 // first RFS
    SAP     AP_RefSearchSpeed, M_linearMotor, SEARCH_SPEED_LINEAR_BOTTLE      // speed for search
    SAP     AP_RefSwitchSpeed, M_linearMotor, SWITCH_SPEED_LINEAR_BOTTLE      // speed for final search
    SAP     AP_RefSearchMode,  M_linearMotor, APV_RefHomeLeft                 // search needle mode
    RFS     START, M_linearMotor                                              // Start reference search
    WAIT    RFS, M_linearMotor, WAIT_NEEDLE_REF          // wait till reaches location or 0.8 seconds
    JC      ETO, secondRFSback                           // timeout occured
    JA      endFindNeedle
secondRFSback:
//    MST     M_linearMotor
    RFS     STOP, M_linearMotor                         // Start reference search
    WAIT    RFS, M_linearMotor, WAIT_TICKS_SHORT        // wait till stops or 2 seconds
    SAP     AP_RefSearchMode,  M_linearMotor, APV_RefHomeRight  // search needle
    RFS     START, M_linearMotor                    // Start reference search
    CSUB    waitLinearMotorRfs
endFindNeedle:
    GAP     AP_LastRefPosition, M_linearMotor         // get position of reference
    AAP     AP_ActualPosition, M_linearMotor          // copy into current location
    AGP     GB_LinearCenterOfBag, GPBank_2            // remember position of reference
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

insertNeedle:    //

 // randomly move the needle right or left +/-20 us (+/-0.5mm)

//    CSUB    getRandom
//    MVPA    REL, M_headRotateMotor                        // move to random location. A holds the amount
//    CSUB    waitRotate

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    GGP     GB_BumpPosVert, GPbank_2                       // load to A
    MVPA    ABS, M_verticalMotor                           // move to location
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL // Set maximum positioning speed
    MVP     REL, M_verticalMotor, VERTICAL_IN_VIAL         // insert needle into vial
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
//    CSUB    checkVialPoppedOut                           // verify that the vial did not pop out
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//getRandom:
//    GGP     GB_RandomNumber, GPbank_0              // get a random number (0. . . 2147483647)
//    CALC    SUB, 1073741820                        // sub half to get  -107374182 to + 107374182
//    CALC    DIV, 1073741820/randomStepsToMove      // devide by to get +/-40
//    RSUB


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

push70air:

    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCX   LOAD                                        // move it to X [uStep/100uL]
    GGP     GB_microLtoWithdraw, GPbank_2               // load the withdraw volume [uL] into A
    CALCX   MUL                                         // A <-- A*X [uSteps*100]
    CALC    DIV, 100                                    // now in uSteps
    CALCX   LOAD                                        // copy to X
    GGP     GB_airToPullBefore, GPbank_2                // get the "70%"
    CALCX   MUL                                         // calculate 70%
    CALC    DIV, 100                                    // A = 70% in uSteps
    CALCX   LOAD                                        // copy to X = 70% in uStep
    GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    CALCX   SUB                                         // add current position to required relative
    CSUB    movePiston
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

drawVial:    // just pull to required volume

    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW   // Set maximum positioning speed
    GGP     GB_pistonMicroStepPer100microL, GPbank_2    // load to A
    CALCX   LOAD                                        // move it to X [uStep/100uL]
    GGP     GB_microLtoWithdraw, GPbank_2               // load the withdraw volume [uL] into A
    CALCX   MUL                                         // A <-- A*X [uSteps*100]
    CALC    DIV, 100                                    // now in uSteps
    CALCX   LOAD                                        // move it to X [uStep/100uL]
    GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
    CALCX   ADD                                         // add current position to required relative
    CSUB    movePiston

    MVP     REL, M_pistonMotor, PISTON_MORE             // move more
    CSUB    waitPiston
    CSUB    waitAfterDraw
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed
returnDrawVial:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

drawVialMoreBack:    // just pull to required volume

    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW  // Set maximum positioning speed
  // always push for later bump
    MVP     REL, M_pistonMotor, -BUMP_DOWN_REL          // re-push to compensate the "bump"
    CSUB    waitPiston
    MVP     REL, M_pistonMotor, -PISTON_MORE            // push back the 300[uL]
    CSUB    waitPiston
// returnMoreBack:
    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST  // Set maximum positioning speed
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitAfterDraw:

    GGP     GB_DrawWaitTime, GPbank_2              // get time in [100ms]
    WAIT    TICKS, 0, ACCUMULATOR_WAIT             // wait ticks as in A
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveSlowlyBottom:    //

    GGP     GB_BumpPosVert, GPbank_2                  // go to required height
    CSUB    moveVertical                         // move, wait and error if delay
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

bumpPlunger:   //

    MVP     REL, M_pistonMotor, BUMP_DOWN_REL           // bump piston
    CSUB    waitPiston
// the piston bump will run in parallel to the vertical down, and wait after start of vertical
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

goIntoBag:   //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed
    GGP     GB_LoadingHight, GPbank_2                                       // load to A
    MVPA    ABS, M_verticalMotor                                            // move to location
    CSUB    waitVertical

    GGP     GB_LinearCenterOfBag, GPbank_2                                  // go left under bag position
    MVPA    ABS, M_linearMotor                                              // move, wait later
    CSUB    waitLinearMotor

    MVP     ABS, M_verticalMotor, SYRINGE_AT_BAG_ENTRY                      // move to location
    CSUB    waitVertical

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_TO_VIAL  // Set maximum positioning speed
    MVP     ABS, M_verticalMotor, SYRINGE_IN_BAG_ABS                            // move to location
    CSUB    waitVertical
    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed

    SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST_SLOW  // Set maximum positioning speed
    GGP     GB_PistonHomePos, GPbank_2                                      // load to A
    MVPA    ABS, M_pistonMotor                                              // re-push to compensate the "bump"
    CSUB    waitPiston
 //   SAP     AP_MaxPositioningSpeed, M_pistonMotor, MAX_POS_SPEED_PIST       // Set maximum positioning speed
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rotateDown:   //

    SAP     AP_MaxPositioningSpeed, M_verticalMotor, MAX_POS_SPEED_VER_HIGH // Set maximum positioning speed

    GGP     GB_LoadingHight, GPbank_2                                      // load to A
    MVPA    ABS, M_verticalMotor                                           // move to location
    CSUB    waitVertical

    MVP     REL, M_headRotateMotor, NEINTY_DEGREES/2         // move to location
    CALC    LOAD, LINEAR_ROTATE_POS
    MVPA    ABS, M_linearMotor                               // move to location
    CSUB    waitRotate
    CSUB    waitLinearMotor

    GGP     GB_HeadRotateHomePos, GPbank_2                   // go back to loading position
    MVPA    ABS, M_headRotateMotor                           // move, wait later
    CSUB    waitRotate
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

recapSyringe:   //

    GGP     GB_linearHomePos, GPbank_2                     // go back to loading position
    MVPA    ABS, M_linearMotor                             // move, wait later
    CSUB    waitLinearMotor                                // wait and error if delay
    CSUB    homeCapHolderMotor                             // to home switch upwards

//    DI      TI_STOPLEFT5                                 //  disable syringe pop out interrupt for this stage
//    CSUB    checkSyrPoppedOut3Times                      // verify that the syringe did not pop out
//    EI      TI_STOPLEFT5                                 //  enable syringe pop out interrupt after checking 3 times if still on

    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

incrementCycles:
    GGP     GB_cyclesTotal, GPbank_2                   // cycles so far into A
    CALC    ADD, 1                                     // add 1 to accumulator
    AGP     GB_cyclesTotal, GPbank_2                   // A to Global parameter
    STGP    GB_cyclesTotal, GPbank_2                   // store it in EEPROM
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Subroutines initialized localy
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Summary: Performs axis homeing
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

FIND_HOMES:

    SGP     GB_HomingDone, GPbank_2, clr            // clear homing done
    CSUB    checkNoSyringeFH                        // make sure no syringe is in
    GGP     GB_any_Error, GPbank_2                  // get any error status
    COMP    ANY_ERROR_EXISTS                        // exists?
    JC      EQ, return_FIND_HOME                    // yes, return
    CSUB    startHomePistonMotor
    CSUB    startHomeDisposeMotor
    CSUB    homeCapHolderMotor                      // Linear and Cap holders first to clear the way for vertical
    CSUB    homeLinearMotor                         // Linear and Cap holders first to clear the way for vertical
    CSUB    positionPistonMotor
    CSUB    positionArmMotor
    CSUB    waitHomeDisposeMotor
    CSUB    positionVerticalMotor                   // get it out of Linear and cap
    CSUB    PositionHeadRotateMotor
    CSUB    positionLinearMotor
    SGP     GB_HomingDone, GPbank_2, set            // home done
return_FIND_HOME:
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

positionVerticalMotor:          // motor 0
    CSUB      homeVerticalMotor                                          // to home switch upwards
    GGP       GB_LoadingHight, GPbank_2
    CSUB      moveVertical
    RSUB
homeVerticalMotor:          // to home switch upwards
    SAP       AP_MaxAcceleration, M_verticalMotor, ACC_VERT_HIGH         // Set maximum acceleration
    SAP       AP_RefSearchMode,  M_verticalMotor, APV_RefLeftSwitch      // set the kind of search just go up
    RFS       START, M_verticalMotor                                     // Start home sw search UP, then' if reached ref, Down
    CSUB      waitVerticalRfs
    SAP       AP_MaxAcceleration, M_verticalMotor, ACC_VERT              // Set maximum acceleration
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

homeLinearMotor:    // motor 1
    SAP       AP_StandbyCurrent, M_linearMotor, STBY_CURRENT_LINEAR_HIGH   // Set standby current
    SAP       AP_RefSearchSpeed, M_linearMotor, SEARCH_SPEED_LINEAR_HOME   // speed for search
    SAP       AP_RefSwitchSpeed, M_linearMotor, SWITCH_SPEED_LINEAR_HOME   // speed for final search
    SAP       AP_RefSearchMode, M_linearMotor, APV_RefLeftSwitch
    RFS       START, M_linearMotor                                         // Start reference search
    CSUB      waitLinearMotorRfs
    RSUB
positionLinearMotor:
    GGP       GB_linearHomePos, GPbank_2
    CSUB      moveLinear

    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

positionArmMotor:             // motor 2
    CSUB      homeArmMotor                                          // to home switch upwards
    GGP       GB_ArmHomePosition, GPbank_2
    CSUB      moveArmMotor
    RSUB
homeArmMotor:  
    SAP       AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH      // Set standby current
    SAP       AP_RefSearchMode, M_armMotor, APV_RefLeftSwitch
    RFS       START, M_armMotor                                     // Start reference search
    CSUB      waitArmMotorRfs
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

homePistonMotor:     // motor 3
    CSUB      startHomePistonMotor
    CSUB      waitPistonRfs
    RSUB
startHomePistonMotor:
    SAP       AP_RefSearchMode,  M_pistonMotor, APV_RefLeftSwitch  
    RFS       START, M_pistonMotor                                          // Start reference search
    RSUB
positionPistonMotor:                                                        // wait home sensor and position
    CSUB      waitPistonRfs
    GGP       GB_PistonHomePos, GPbank_2                                    // go to required height
    CSUB      movePiston                                                    // move, wait and error if delay
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PositionHeadRotateMotor:   // motor 4
    CSUB      HomeHeadRotateMotor
    GGP       GB_HeadRotateHomePos, GPbank_2                                // go to required height
    CSUB      moveRotate                                                    // move, wait and error if delay
    RSUB
HomeHeadRotateMotor:   
    CSUB      homeHeadRotateMotorFast                                       // find fast, before slow
//    CSUB      homeHeadRotateMotorSlow                                     // find fast, before slow
    RSUB
homeHeadRotateMotorSlow:
    SAP       AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT_SLOW   // speed for search slow
    SAP       AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT_SLOW   // speed for final search
    SAP       AP_RefSearchMode,  M_headRotateMotor, APV_RefLeftSwitch  
    RFS       START, M_headRotateMotor                                      // Start reference search
    CSUB      waitRotateRfs
    RSUB
homeHeadRotateMotorFast:   
    SAP       AP_RefSearchSpeed, M_headRotateMotor, SEARCH_SPEED_ROT        // speed for search
    SAP       AP_RefSwitchSpeed, M_headRotateMotor, SWITCH_SPEED_ROT        // speed for final search
    SAP       AP_RefSearchMode,  M_headRotateMotor, APV_RefLeftSwitch  
    RFS       START, M_headRotateMotor                                      // Start reference search
    CSUB      waitRotateRfs
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

startHomeDisposeMotor:       // motor 5
    SAP       AP_StandbyCurrent, M_disposeMotor, STBY_CURRENT_DISPOSE   // Set standby current
    SAP       AP_RefSearchMode, M_disposeMotor, APV_RefLeftSwitch
    RFS       START, M_disposeMotor                                     // Start reference search
    RSUB

waitHomeDisposeMotor:
    CSUB      waitDisposeRfs
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

homeCapHolderMotor:     // func 132

    SGP   GB_UnitsToMoveManual, GPbank_2, -6000     // move upward 10 mm till stop at home sensor
    CSUB  CapHolderManual                           // FUNC 140  run and error if too long
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

verticalMotorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_verticalMotor, GPbank_2         // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_verticalMotor, GPbank_2         // and write again
    STGP    GB_errors_M_verticalMotor, GPbank_2         // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
   JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LinearMotorTOerr:   

    CSUB    setAnyError
    GGP     GB_errors_M_linearMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                        // add the error bit
    AGP     GB_errors_M_linearMotor, GPbank_2        // and write again
    STGP    GB_errors_M_linearMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

armMotorTOerr:  

    CSUB    setAnyError
    GGP     GB_errors_M_armMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                     // add the error bit
    AGP     GB_errors_M_armMotor, GPbank_2        // and write again
    STGP    GB_errors_M_armMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

pistonMotorTOerr:   

    CSUB    setAnyError
    GGP     GB_errors_M_pistonMotor, GPbank_2           // load piston error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_pistonMotor, GPbank_2           // and write again
    STGP    GB_errors_M_pistonMotor, GPbank_2           // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

headRotateMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_headRotateMotor, GPbank_2        // load piston error word
    CALC    OR, BitEr_TimeOut                            // add the error bit
    AGP     GB_errors_M_headRotateMotor, GPbank_2        // and write again
    STGP    GB_errors_M_headRotateMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

disposeMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_disposeMotor, GPbank_2         // load disposal error word
    CALC    OR, BitEr_TimeOut                          // add the error bit
    AGP     GB_errors_M_disposeMotor, GPbank_2         // and write again
    STGP    GB_errors_M_disposeMotor, GPbank_2         // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

capHolderMotorTOerr:

    CSUB    setAnyError
    GGP     GB_errors_M_capHolderMotor, GPbank_2        // load cap holder error word
    CALC    OR, BitEr_TimeOut                           // add the error bit
    AGP     GB_errors_M_capHolderMotor, GPbank_2        // and write again
    STGP    GB_errors_M_capHolderMotor, GPbank_2        // and store it
    SGP     GB_CurrentState, GPbank_2, STOPPED_TIME_OUT
    JA      ABORT_NoReport

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkSyrPoppedOut:

    GAP     AP_RightLimitSwitchState, M_pistonMotor     // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut                      // if in, continue to check vial
 // syringe popped out, signal errors
    GGP     GB_errors_syringe, GPbank_2          // load Ver002 error word
    CALC    OR, BitEr_syringePoppedOut                  // add the error bit
    AGP     GB_errors_syringe, GPbank_2          // and write again
    STGP    GB_errors_syringe, GPbank_2          // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnSyrPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkSyrPoppedOut3Times:

    GAP     AP_RightLimitSwitchState, M_pistonMotor     // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut3                     // if in, continue to check vial
 // try again
    WAIT    TICKS, 0, WAIT_TICKS_200ms                  // wait ticks as in A
    GAP     AP_RightLimitSwitchState, M_pistonMotor     // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut3                     // if in, continue to check vial
 // and again
    WAIT    TICKS, 0, WAIT_TICKS_200ms                  // wait ticks as in A
    GAP     AP_RightLimitSwitchState, M_pistonMotor     // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      EQ, returnSyrPoppedOut3                     // if in, continue to check vial

 // syringe popped out, signal errors
    GGP     GB_errors_syringe, GPbank_2          // load Ver002 error word
    CALC    OR, BitEr_syringePoppedOut                  // add the error bit
    AGP     GB_errors_syringe, GPbank_2          // and write again
    STGP    GB_errors_syringe, GPbank_2          // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnSyrPoppedOut3:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkVialPoppedOut:

//    GIO     In_VialInPlace, InBankDigital_0           // check if syringe is in
    COMP    VIAL_IS_LOADED                              // is the syringe in?
    JC      EQ, returnVialPoppedOut                     // if not, continue
 // vial popped out, signal errors
    GGP     GB_errors_syringe, GPbank_2          // load Ver002 error word
    CALC    OR, BitEr_VialPoppedOut                     // add the error bit
    AGP     GB_errors_syringe, GPbank_2          // and write again
    STGP    GB_errors_syringe, GPbank_2          // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      ABORT

returnVialPoppedOut:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkNoSyringeFH:

    CSUB    checkSyringeSensor  // AP_RightLimitSwitchState, M_pistonMotor  // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      NE, noSyringeFH                             // if not, continue
    // syringe found, signal errors
    GGP     GB_errors_findHome, GPbank_2                // load piston error word
    CALC    OR, BitEr_syringeIsInwhileFindHome          // add the error bit
    AGP     GB_errors_findHome, GPbank_2                // and write again
    STGP    GB_errors_findHome, GPbank_2                // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckNoSyringeFH

noSyringeFH:
    GGP     GB_errors_findHome, GPbank_2                // load piston error word
    CALC    OR, BitEr_syringeIsInwhileFindHome          // add the error bit
    CALC    XOR, BitEr_syringeIsInwhileFindHome         // Clear the error bit
    AGP     GB_errors_findHome, GPbank_2                // and write again
    STGP    GB_errors_findHome, GPbank_2                // and store it

returnCheckNoSyringeFH:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkOkToInitDrawDoze:

    SGP     GB_errors_wrong_PC_command, GPbank_2, clr
    GGP     GB_CurrentState, GPbank_2   // InitDrawDoze can run if WAITING_INIT_DRAW_DOSE or if WAITING_DRAW_DOSE
    COMP    WAITING_INIT_DRAW_DOSE                       // WAITING_INIT_DRAW_DOSE?
    JC      EQ, okToInitDrawDoze                         // yes, return
    GGP     GB_CurrentState, GPbank_2                    // no, try next
    COMP    WAITING_DRAW_DOSE                            // WAITING_DRAW_DOSE?
    JC      EQ, okToInitDrawDoze                         // yes, return
    // InitDrawDoze does not fit, signal errors
    GGP     GB_errors_wrong_PC_command, GPbank_2         // load error word
    CALC    OR, BitEr_expecting_GP5_10_OR_30             // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2         // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2         // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow
    JA      returnCheckInitDraw

okToInitDrawDoze:    
    SGP     GB_CurrentState, GPbank_2, RUNNING_INIT_DRAW_DOSE

returnCheckInitDraw:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkNoSyringe:

    CSUB    checkSyringeSensor                          // put syringe status in A
    COMP    SYRINGE_IN_PLACE                            // is the syringe in?
    JC      NE, returnCheckNoSyringe                    // if not, continue
    // syringe found, signal errors
    GGP     GB_special_Error, GPbank_2                  // load the error word
    CALC    OR, BitEr_SyringeIsIn                       // add the error bit
    AGP     GB_special_Error, GPbank_2                  // and write again
    STGP    GB_special_Error, GPbank_2                  // and store it
    CSUB    setStateSTOPPED_ON_ERROR_Yellow

returnCheckNoSyringe:
    RSUB

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

checkSyringeSensor:
    GAP     AP_RightLimitSwitchState, M_pistonMotor     // put syringe status in A
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Manual Axis movements 
//  Use carefully, only in direct mode
//  The movement consists of the following commands.
//  The global parameter GP_uPulsesManual (address 19)  holds the micro-meters 
//  or mili-degrees to go, which can be negative or positive.
//  Before sending the next movement look if GB_MotorIsMoving (GB_16) is clear
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

VerticalManual:    // func 136

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALC    MUL, verticalMicroStepsPerMM              
    CALC    DIV, 1000                                   // now in uSteps
//    CALCX   LOAD                                        // move it to X [uStep]
//    GAP     AP_ActualPosition, M_verticalMotor          // get current position to A
//    CALCX   ADD                                         // add current position to required relative
    MVPA    REL, M_verticalMotor                         // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS_SHORT      // wait till reaches location or 2 seconds
    JC      ETO, verticalMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB    

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveVertical:    // 

    MVPA    ABS, M_verticalMotor                         // move, wait later
    CSUB    waitVertical
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVertical:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS            // wait till reaches location or 10 seconds
    JC      ETO, verticalMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVerticalLong:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_verticalMotor, WAIT_TICKS_LONG        // wait till reaches location or 15 seconds
    JC      ETO, verticalMotorTOerr                      // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
 
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitVerticalRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_verticalMotor, WAIT_TICKS_LONG         // wait end of reference search 15 seconds
    JC      ETO, verticalMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
 
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

LinearMotorManual:    //   func 138

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [mDeg] into A
    CALC    MUL, linearMicroStepsPerRev                
    CALC    DIV, 1000                                   // now in mDeg
//    CALCX   LOAD                                        // move it to X
//    GAP     AP_ActualPosition, M_linearMotor            // get current position to A
//    CALCX   ADD                                         // add current position to required relative
    MVPA    REL, M_linearMotor                            // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_linearMotor, WAIT_TICKS_SHORT        // wait till reaches location or 2 second
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB    

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveLinear:    // 

    MVPA    ABS, M_linearMotor                            // move, wait later
    CSUB    waitLinearMotor
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitLinearMotor:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_linearMotor, WAIT_TICKS           // wait till reaches location or 10 seconds
    JC      ETO, LinearMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitLinearMotorRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_linearMotor, WAIT_TICKS           // wait end of reference search 15 seconds
    JC      ETO, LinearMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

armMotorManual:    //   func 140

    SAP     AP_StandbyCurrent, M_armMotor, STBY_CUR_ARM_HIGH      // Set standby current
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2        // load the movement [mDeg] into A
    CALC    MUL, ArmMicrostepsPerDeg                
    CALC    DIV, 1000                             // now in mDeg
//    CALCX   LOAD                                  // move it to X 
//    GAP     AP_ActualPosition, M_armMotor         // get current position to A
//    CALCX   ADD                                   // add current position to required relative
    MVPA    REL, M_armMotor                         // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_armMotor, WAIT_TICKS_SHORT     // wait till reaches location or 2 seconds
    JC      ETO, armMotorTOerr              // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveArmMotor:    // 

    MVPA    ABS, M_armMotor                         // move, wait later
    CSUB    waitArmMotor
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitArmMotor:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_armMotor, WAIT_TICKS            // wait till reaches location or 10 seconds
    JC      ETO, armMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitArmMotorRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_armMotor, WAIT_TICKS           // wait end of reference search 15 seconds
    JC      ETO, armMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

PistonManual:    // func 142

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALC    MUL, pistonMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
//    CALCX   LOAD                                        // move it to X [uStep]
//    GAP     AP_ActualPosition, M_pistonMotor            // get current position to A
//    CALCX   ADD                                         // add current position to required relative
    MVPA    REL, M_pistonMotor                            // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS_SHORT        // wait till reaches location or 2 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

movePiston:    // 

    MVPA    ABS, M_pistonMotor                            // move, wait later
    CSUB    waitPiston
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPiston:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_pistonMotor, WAIT_TICKS              // wait till reaches location or 10 seconds
    JC      ETO, pistonMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitPistonRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_pistonMotor, WAIT_TICKS             // wait end of reference search 15 seconds
    JC      ETO, pistonMotorTOerr                      // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

RotationManual:    //   func 144

    SAP     AP_StandbyCurrent, M_headRotateMotor, STBY_CUR_ROTATE_HIGH  // Set standby current 
    SAP     AP_LeftLimitSwitchDisable, M_headRotateMotor, set           // Disable left limit switch
    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [mDeg] into A
    CALC    MUL, rotateMicrostepsPerDeg                 // 
    CALC    DIV, 1000                                   // now in mDeg
//    CALCX   LOAD                                        // move it to X 
//    GAP     AP_ActualPosition, M_headRotateMotor        // get current position to A
//   CALCX   ADD                                         // add current position to required relative
    MVPA    REL, M_headRotateMotor                        // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS_SHORT    // wait till reaches location or 2 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveRotate:    // 

    MVPA    ABS, M_headRotateMotor                        // move, wait later
    CSUB    waitRotate
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotate:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS          // wait till reaches location or 10 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateLong:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_headRotateMotor, WAIT_TICKS_LONG     // wait till reaches location or 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_LONG     // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsShort:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_SHORT   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                  // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsNeedle:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_NEEDLE   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                   // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitRotateRfsVeryShort:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_headRotateMotor, WAIT_TICKS_VERY_SHORT   // wait end of reference search 15 seconds
    JC      ETO, headRotateMotorTOerr                       // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DisposeManual:    //   func 154

    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // load the movement [uMeter] into A
    CALC    MUL, disposeMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
//    CALCX   LOAD                                        // move it to X [uStep]
//    GAP     AP_ActualPosition, M_disposeMotor        // get current position to A
//    CALCX   ADD                                         // add current position to required relative
    MVPA    REL, M_disposeMotor                        // move, wait later
    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_disposeMotor, WAIT_TICKS_SHORT    // wait till reaches location or 2 seconds
    JC      ETO, disposeMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

moveDispose:    // 

    MVPA    ABS, M_disposeMotor                        // move, wait later
    CSUB    waitPiston
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitDispose:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    POS, M_disposeMotor, WAIT_TICKS          // wait till reaches location or 10 seconds
    JC      ETO, disposeMotorTOerr                     // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

waitDisposeRfs:    // 

    SGP     GB_MotorIsMoving, GPbank_2, set
    WAIT    RFS, M_disposeMotor, WAIT_TICKS         // wait end of reference search 15 seconds
    JC      ETO, disposeMotorTOerr                    // timeout occured
    SGP     GB_MotorIsMoving, GPbank_2, clr

    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CapHolderManual:   // FUNC 156   

//   GB_UnitsToMoveManual             = 19    // for manual movement, put here the microMeter or Mili Degree to move (+/-)
//   GB_CapHolderPulses               = 55    
//   GB_slowCapHolder                 = 88

//    SGP     GB_CurrentState, GPbank_2, WAITING_INIT_DRAW_DOSE
    GGP     GB_UnitsToMoveManual, GPbank_2              // GB_19 load the movement [uMeter] into A
    CALC    MUL, capHolderMicroStepsPerMM           
    CALC    DIV, 1000                                   // now in uSteps
    CALCVA  LOAD, GB_CapHolderPulses                    // The required pulses in GB
    SGP     GB_MotorIsMoving, GPbank_2, set
// check direction
    SIO     Out_CAPHolderDIR_Down, OutBank_2, set       // assume "down", positive steps
    GGP     GB_UnitsToMoveManual, GPbank_2              // GB_19 load the movement [uMeter] into A
    COMP    0
    JC      GE, CapGoDownwards                          // as assumed
// change to UP
    SIO     Out_CAPHolderDIR_Down, OutBank_2, clr       // assume positive steps, go up
    CALCV   MUL, GB_CapHolderPulses, -1                 // change pulses to absolute
CapGoDownwards:
// move the motor
    SGP     GB_MotorIsMoving, GPbank_2, set
    SGP     GB_capWaitLoops, GPbank_2, CAP_WAIT_LOOPS

nextStep:   //  loop
// check if to test sensor
    GIO     Out_CAPHolderDIR_Down, InBankOuput_2
    COMP    1
    JC      EQ, moveOneStep                             // going down, don't check sensor
//    GGP     GB_CapLimitSwitchDisable, GPbank_2
//    COMP    DISABLE_SENSOR
//    JC      EQ, moveOneStep                           // going down, don't check sensor
    GIO     In_capHolderHome, InBankDigital_0                 
    COMP    CAP_HOLDER_AT_HOME             
    JC      EQ, exitCapHolderManual                     // reached home sensor, exit
moveOneStep:
    SIO     Out_PulseCapHolder, OutBank_2, 0            // pulse up
    SIO     Out_PulseCapHolder, OutBank_2, 1            // pulse down
    GGP     GB_slowCapHolder, GPbank_2                  // move slowy?
    COMP    0
    JC      ZE, fastLoop
    WAIT    TICKS, 0, 1                                 // wait 10 ms
fastLoop:
    DJNZ    GB_capWaitLoops, contCap                    // check if 10 seconds passed (5000 loops)
    JA      capHolderMotorTOerr                         // if stuck, error
contCap:
    DJNZ    GB_CapHolderPulses, nextStep                //  if not zero: decrement and jump 
exitCapHolderManual:
    SGP     GB_MotorIsMoving, GPbank_2, clr
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 testCapHolder:    // func 158

    SGP   GB_UnitsToMoveManual, GPbank_2, -6000              // move up to start position
    CSUB  CapHolderManual
    SGP   GB_UnitsToMoveManual, GPbank_2, CAP_LOCK_STEPS     // move down to close position
    CSUB  CapHolderManual
    WAIT  TICKS, 0, 100                                      // wait 1 s
    JA    testCapHolder
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// VIBRATE
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
defaultVibrate:   // func 126
    SGP    GB_vibrationTime_4, GPbank_2, 3
    SGP    GB_vibrationTime_56, GPbank_2, 2
    SGP    GB_vibrationHz, GPbank_2, 25
    SGP    GB_vibrationStrengthPercent, GPbank_2, 40
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
StopVibrate:   // FUNC 120   
    DI     TI_TIMER0     
    DI     TI_TIMER1 
    DI     TI_TIMER2 
    SGP    GB_vibrator4done, GPbank_2, 1
    SGP    GB_vibrator56done, GPbank_2, 1
    CALCV  LOAD, GB_vibrationTime_4_calc, 0
    CALCV  LOAD, GB_vibrationTime_56_calc, 0
    SIO    Out_enaVibrate_0, GPbank_2, 1           // switch off OUT0 high vibrator 0
    SIO    Out_enaVibrate_1, GPbank_2, 1           // switch off OUT1 high vibrator 1
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Vibrate:   // FUNC 114   

// GB_vibrationTime_4           = 114
// GB_vibrationTime_4_calc      = 115
// GB_vibrationTime_56          = 116
// GB_vibrationTime_56_calc     = 117
// GB_vibrationStrengthPercent  = 123        // 10/20/30/40/.../100
// GB_vibrStrengthPercentCalc   = 119        // set up %
// GB_PwmDutyCycleMS            = 120        // calculated [ms]
// GB_vibrator4done             = 121
// GB_vibrator56done            = 122
// GB_vibrationCycleMS          = 124        // ms
// GB_vibrationHz               = 125        // data input

//  reset current vibration
    CSUB   StopVibrate

// check strength validity                       // acceptable values 10-100
    GGP      GB_vibrationStrengthPercent, GPbank_2
    COMP     10               
    JC       LT, errorVibrateParameter
    GGP      GB_vibrationStrengthPercent, GPbank_2
    COMP     100
    JC       GT, errorVibrateParameter

// check HZ validity                       // acceptable values 4-100 HZ
    GGP      GB_vibrationHz, GPbank_2
    COMP     100
    JC       GT, errorVibrateParameter
    GGP      GB_vibrationHz, GPbank_2
    COMP     4
    JC       LT, errorVibrateParameter

// check TIME validity                       // acceptable values > 0 [s]
    GGP      GB_vibrationTime_4, GPbank_2
    COMP     0
    JC       LT, errorVibrateParameter
    GGP      GB_vibrationTime_56, GPbank_2
    COMP     0
    JC       LT, errorVibrateParameter

// load parameters
    CALCVV   LOAD, GB_vibrationTime_4_calc, GB_vibrationTime_4
    CALCVV   LOAD, GB_vibrationTime_56_calc, GB_vibrationTime_56

// calculate cycle time from HZ
    CALC     LOAD, 500                     // load 500 to A
    CALCAV   DIV, GB_vibrationHz           // A=500 / HZ = ms
    CALCVA   LOAD, GB_vibrationCycleMS     // load into GB

// calculate duty cycle time
    CALCVV   LOAD, GB_vibrStrengthPercentCalc, GB_vibrationStrengthPercent
    //CALCV    MUL, GB_vibrStrengthPercentCalc, 10                  // 1->10 ... 10->100 
    CALCVV   LOAD, GB_PwmDutyCycleMS, GB_vibrationCycleMS          // ms
    CALCVV   MUL, GB_PwmDutyCycleMS, GB_vibrStrengthPercentCalc   // ms * % *100
    CALCV    DIV, GB_PwmDutyCycleMS, 100                           // :100 = ms

    SGP    GB_vibrator4done, GPbank_2, 0     // will sign when it finished
    SGP    GB_vibrator56done, GPbank_2, 0    // will sign when it finished
    CSUB   initInterrups                     // re-initialize
    JA     endVibrate

errorVibrateParameter:
    GGP     GB_errors_wrong_PC_command, GPbank_2        // load Ver002 error word
    CALC    OR, BitEr_vibrateParemeterError             // add the error bit
    AGP     GB_errors_wrong_PC_command, GPbank_2        // and write again
    STGP    GB_errors_wrong_PC_command, GPbank_2        // and store it
    CSUB    setStateSTOPPED_ON_ERROR
    JA      ABORT_NoReport
    
endVibrate:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  calibration functions  
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HomeCalibration:
    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_verticalMotor
    JC      EQ, calibMotorVertical

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_linearMotor
    JC      EQ, calibMotorLinear

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_armMotor
    JC      EQ, calibMotorArm

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_pistonMotor
    JC      EQ, calibMotorPiston

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_headRotateMotor
    JC      EQ, calibMotorRotate

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_capHolderMotor
    JC      EQ, calibMotorCap

    GGP     GB_motorNumForHome, GPbank_2               // the motor number to send to home
    COMP    M_disposeMotor
    JC      EQ, calibMotorDispose

    JA     returnHomeCalibration

calibMotorVertical:
    CSUB   homeVerticalMotor
    JA     returnHomeCalibration

calibMotorLinear:
    CSUB   homeLinearMotor
    JA     returnHomeCalibration

calibMotorArm:
    CSUB   homeCapHolderMotor
    JA     returnHomeCalibration

calibMotorPiston:
    CSUB   homePistonMotor
    JA     returnHomeCalibration

calibMotorRotate:
    CSUB   HomeHeadRotateMotor
    JA     returnHomeCalibration

calibMotorDispose:
    JA     returnHomeCalibration

calibMotorCap:
    JA     returnHomeCalibration

returnHomeCalibration:
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setStateSTOPPED_ON_ERROR:

    SGP     GB_CurrentState, GPbank_2, STOPPED_ON_ERROR
    CSUB    setAnyError
    RSUB
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setStateSTOPPED_ON_ERROR_Yellow:

    SGP     GB_CurrentState, GPbank_2, STOPPED_ON_ERROR
    STGP    GB_CurrentState, GPbank_2
    CSUB    setAnyErrorYellow
    RSUB
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setAnyError:

    SGP     GB_any_Error, GPbank_2, set                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    RED_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

setAnyErrorYellow:

    SGP     GB_any_Error, GPbank_2, set                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    YELLOW_ON
    RSUB

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

clrAnyError:

    SGP     GB_any_Error, GPbank_2, clr                  // signal error: general
    STGP    GB_any_Error, GPbank_2                       // declare any error  
    CSUB    GREEN_ON
    RSUB


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
GREEN_ON:
    SIO     Out_RedLED, OutBank_2, LED_OFF                   // turn off red led
    SIO     Out_GreenLED, OutBank_2, LED_ON                  // turn on green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
RED_ON:
    SIO     Out_RedLED, OutBank_2, LED_ON                    // turn on red led
    SIO     Out_GreenLED, OutBank_2, LED_OFF                 // turn off green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
YELLOW_ON:
    SIO     Out_RedLED, OutBank_2, LED_ON                     // turn on red led
    SIO     Out_GreenLED, OutBank_2, LED_ON                   // turn on green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LEDS_OFF:
    SIO     Out_RedLED, OutBank_2, LED_OFF                    // turn off red led
    SIO     Out_GreenLED, OutBank_2, LED_OFF                  // turn off green led
    RSUB

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

